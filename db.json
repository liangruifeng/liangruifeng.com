{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b8e5951c497e1060bfccf7be197be3bad8cb1885","modified":1592378408812},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1592375908419},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1592375908419},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1592375908419},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1592375908420},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1592375908420},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1592375908420},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1592375908420},{"_id":"themes/yilia/_config.yml","hash":"0b7075bab3dbcf01a8f25d22c43aca41cb89860d","modified":1592380394466},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1592375908429},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1592375908452},{"_id":"source/categories/index.md","hash":"3758cbbb1f24f34702d38064154dc38e7c29d8bf","modified":1568472747000},{"_id":"source/_posts/linux-sed.md","hash":"599f66af3d5c9be939a8580574cf4e7d9ac36446","modified":1592491781454},{"_id":"source/_posts/python-函数参数.md","hash":"47d6e3ff44f05b0b7ad21e1b7e7fbe47522cd26f","modified":1592492462029},{"_id":"source/_posts/python-生成器迭代器.md","hash":"0317a144b8cfbd38fdfc7345316bdae88fb5cd65","modified":1592493404767},{"_id":"source/_posts/python-装饰器.md","hash":"a83c23c31b803ed9d93a05af6226be96824a5749","modified":1592491894304},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1592381412180},{"_id":"source/images/avatar.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1475336441000},{"_id":"source/tags/index.md","hash":"bad6b1f2027e7a220c65b438d8cc042342a4002d","modified":1568472756000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1592375908416},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1592375908417},{"_id":"themes/yilia/.git/index","hash":"108c531a21ca8ddd81b95d326696535b3cb625c4","modified":1592376781929},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1592374955738},{"_id":"themes/yilia/.git/packed-refs","hash":"76b1aa9479dd3de329935b6d94a6624c5f716d23","modified":1592375908414},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1592375908421},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1592375908421},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1592375908421},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1592375908421},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1592375908421},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1592375908421},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1592375908421},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1592375908428},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1592375908428},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1592375908428},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1592375908428},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1592375908428},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1592375908429},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1592375908429},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1592375908450},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1592375908452},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1592375908430},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1592375908445},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1592375908427},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1592375908451},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1592375908451},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1592374955739},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1592374955738},{"_id":"themes/yilia/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1592374955740},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1592374955741},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1592374955741},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1592374955739},{"_id":"themes/yilia/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1592374955741},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1592374955741},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1592374955739},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1592374955740},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1592374955740},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"92e81cca38312414b140f52b9de0655ee232f65f","modified":1592374955742},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1592374955738},{"_id":"themes/yilia/.git/logs/HEAD","hash":"60493df14b4ead0d2011e8301f40e422a0a39280","modified":1592375908416},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1592375908422},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1592375908422},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1592375908422},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1592375908422},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1592375908422},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1592375908422},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1592375908422},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1592375908423},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1592375908423},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1592375908423},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1592375908423},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1592375908423},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1592375908424},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1592375908424},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1592375908427},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1592375908428},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1592375908446},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1592375908447},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1592375908447},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1592375908447},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1592375908448},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1592375908448},{"_id":"themes/yilia/source/img/avatar.png","hash":"c0fda117fa166d63b9eb690cc5e4fb2caaf493b3","modified":1592380273318},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1592375908448},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1592375908449},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1592375908449},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1592375908430},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1592375908430},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1592375908430},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1592375908431},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1592375908431},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1592375908431},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1592375908431},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1592375908432},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1592375908432},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1592375908433},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1592375908437},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1592375908437},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1592375908437},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1592375908437},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1592375908438},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1592375908438},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1592375908439},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1592375908439},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1592375908439},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1592375908439},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1592375908440},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1592375908440},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1592375908440},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1592375908440},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1592375908440},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1592375908441},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1592375908441},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1592375908442},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1592375908442},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1592375908443},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1592375908443},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1592375908443},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1592375908444},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1592375908444},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1592375908444},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1592375908444},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1592375908445},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1592375908445},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1592375908445},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1592375908427},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1592375908416},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1592375908424},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1592375908424},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1592375908424},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1592375908425},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1592375908425},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1592375908425},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1592375908425},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1592375908425},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1592375908426},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1592375908426},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1592375908435},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1592375908434},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1592375908436},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1592375908432},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1592375908436},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1592375908432},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1592375908433},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1592375908433},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1592375908437},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1592375908437},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1592375908438},{"_id":"themes/yilia/.git/objects/pack/pack-7e7ad76c76d9244ab86cf5f4ff5e16d81d3683d7.idx","hash":"32346bb203192ae03913eba00f8048f3d92857c0","modified":1592375908395},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1592375908433},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"60493df14b4ead0d2011e8301f40e422a0a39280","modified":1592375908417},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1592375908415},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"60493df14b4ead0d2011e8301f40e422a0a39280","modified":1592375908415},{"_id":"themes/yilia/.git/objects/pack/pack-7e7ad76c76d9244ab86cf5f4ff5e16d81d3683d7.pack","hash":"3b52bd348dcece8f60e1b458c64c28df78f3a381","modified":1592375908393}],"Category":[],"Data":[],"Page":[{"title":"目录","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 目录\ntype: \"categories\"\ncomments: false\n---\n","date":"2020-05-13T13:03:10.862Z","updated":"2019-09-14T14:52:27.000Z","path":"categories/index.html","layout":"page","_id":"ckbllvcmg0000v7gp577jywd9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\ncomments: false\n---\n","date":"2020-05-13T13:03:10.862Z","updated":"2019-09-14T14:52:36.000Z","path":"tags/index.html","layout":"page","_id":"ckbllvcn4000bv7gp1fk3i893","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Linux文本处理三剑客之sed","date":"2018-10-13T14:12:02.000Z","_content":"\n&emsp;&emsp;sed是stream editor(流编辑器)的缩写，是linux中文本处理非常重要的工具。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”(pattern space)，接着用sed命令处理模式空间中的内容，处理完成后，把缓冲区的内容输出，接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，因为这些都在模式空间处理的。sed可以用来自动编辑一个或多个文件。\n\n<!-- more -->\n\n## 1. 命令格式\n>sed [options] [command] file(s)\n\n##### [option] 选项\n> -n: 仅显示处理后的结果；\n-i: 直接修改读取的文件内容，而不是输出到终端；\n-e &lt;script&gt;: 以选项中的指定的script来处理输入的文本文件；\n-f &lt;script file&gt;: 以选项中指定的script文件来处理输入的文本文件；\n\n##### [command] 命令\n> a: 新增，在当前行下面插入文本；\nc: 取代， 把选定的行改为新的文本；\nd: 删除，删除选择的行；\ni: 插入， 在当前行上面插入文本；\np: 打印，打印选择行数据，通常与sed -n一起使用；\ns: 替换，替换指定字符串，通常与正则表达式一起使用；\n\n## 2. 用法实例\n##### 替换操作\n将file文件中每一行第一个的oldStr替换成newStr\n> sed 's/oldStr/newStr/' file   \n\n使用后缀g标记会替换每一行中的所有匹配 \n> sed 's/oldStr/newStr/g' file \n\n-n选项和p命令一起使用表示只打印那些发生替换的行    \n> sed -n 's/oldStr/newStr/p' \n\n当需要从第N处匹配开始替换时，可以使用 /Ng\n> echo testtesttesttest | sed 's/test/TEST/2'   \n> testTESTtesttest\n\n##### 定界符\n其中 / 在sed中作为定界符使用，也可以使用任意的定界符：\n> sed 's|oldStr|newStr|' file \n> sed 's:oldStr:newStr:' file   \n\n定界符出现在样式内部时，需要进行转义：\n> echo /bin | sed 's/\\/bin/\\/usr\\/local\\/bin/g'\n> /usr/local/bin\n\n##### 删除操作\n删除空白行：\n> sed '/^$/d' file\n\n删除文件的第2行：\n> sed '2d' file\n\n删除文件的第2行到第5行：\n> sed '2,5d' file\n\n删除文件中所有开头是test的行：\n> sed '/^test/'d file\n\n##### 多点编辑\n-e选项允许在同一行里执行多条命令。先删除1至5行，再用test替换TEST：\n> sed -e '1,5d' -e 's/test/TEST/' file\n    \n##### 从文件读入\nfile里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面：\n> sed '/test/r file' filename\n\n\n##### 写入文件\n在example中所有包含test的行都被写入file里\n> sed -n '/test/w file' example\n","source":"_posts/linux-sed.md","raw":"---\ntitle: Linux文本处理三剑客之sed\ndate: 2018-10-13 22:12:02\ntags: [linux]\n---\n\n&emsp;&emsp;sed是stream editor(流编辑器)的缩写，是linux中文本处理非常重要的工具。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”(pattern space)，接着用sed命令处理模式空间中的内容，处理完成后，把缓冲区的内容输出，接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，因为这些都在模式空间处理的。sed可以用来自动编辑一个或多个文件。\n\n<!-- more -->\n\n## 1. 命令格式\n>sed [options] [command] file(s)\n\n##### [option] 选项\n> -n: 仅显示处理后的结果；\n-i: 直接修改读取的文件内容，而不是输出到终端；\n-e &lt;script&gt;: 以选项中的指定的script来处理输入的文本文件；\n-f &lt;script file&gt;: 以选项中指定的script文件来处理输入的文本文件；\n\n##### [command] 命令\n> a: 新增，在当前行下面插入文本；\nc: 取代， 把选定的行改为新的文本；\nd: 删除，删除选择的行；\ni: 插入， 在当前行上面插入文本；\np: 打印，打印选择行数据，通常与sed -n一起使用；\ns: 替换，替换指定字符串，通常与正则表达式一起使用；\n\n## 2. 用法实例\n##### 替换操作\n将file文件中每一行第一个的oldStr替换成newStr\n> sed 's/oldStr/newStr/' file   \n\n使用后缀g标记会替换每一行中的所有匹配 \n> sed 's/oldStr/newStr/g' file \n\n-n选项和p命令一起使用表示只打印那些发生替换的行    \n> sed -n 's/oldStr/newStr/p' \n\n当需要从第N处匹配开始替换时，可以使用 /Ng\n> echo testtesttesttest | sed 's/test/TEST/2'   \n> testTESTtesttest\n\n##### 定界符\n其中 / 在sed中作为定界符使用，也可以使用任意的定界符：\n> sed 's|oldStr|newStr|' file \n> sed 's:oldStr:newStr:' file   \n\n定界符出现在样式内部时，需要进行转义：\n> echo /bin | sed 's/\\/bin/\\/usr\\/local\\/bin/g'\n> /usr/local/bin\n\n##### 删除操作\n删除空白行：\n> sed '/^$/d' file\n\n删除文件的第2行：\n> sed '2d' file\n\n删除文件的第2行到第5行：\n> sed '2,5d' file\n\n删除文件中所有开头是test的行：\n> sed '/^test/'d file\n\n##### 多点编辑\n-e选项允许在同一行里执行多条命令。先删除1至5行，再用test替换TEST：\n> sed -e '1,5d' -e 's/test/TEST/' file\n    \n##### 从文件读入\nfile里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面：\n> sed '/test/r file' filename\n\n\n##### 写入文件\n在example中所有包含test的行都被写入file里\n> sed -n '/test/w file' example\n","slug":"linux-sed","published":1,"updated":"2020-06-18T14:49:41.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbllvcmh0001v7gpgp30bc7s","content":"<p>&emsp;&emsp;sed是stream editor(流编辑器)的缩写，是linux中文本处理非常重要的工具。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”(pattern space)，接着用sed命令处理模式空间中的内容，处理完成后，把缓冲区的内容输出，接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，因为这些都在模式空间处理的。sed可以用来自动编辑一个或多个文件。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-命令格式\"><a href=\"#1-命令格式\" class=\"headerlink\" title=\"1. 命令格式\"></a>1. 命令格式</h2><blockquote>\n<p>sed [options] [command] file(s)</p>\n</blockquote>\n<h5 id=\"option-选项\"><a href=\"#option-选项\" class=\"headerlink\" title=\"[option] 选项\"></a>[option] 选项</h5><blockquote>\n<p>-n: 仅显示处理后的结果；<br>-i: 直接修改读取的文件内容，而不是输出到终端；<br>-e &lt;script&gt;: 以选项中的指定的script来处理输入的文本文件；<br>-f &lt;script file&gt;: 以选项中指定的script文件来处理输入的文本文件；</p>\n</blockquote>\n<h5 id=\"command-命令\"><a href=\"#command-命令\" class=\"headerlink\" title=\"[command] 命令\"></a>[command] 命令</h5><blockquote>\n<p>a: 新增，在当前行下面插入文本；<br>c: 取代， 把选定的行改为新的文本；<br>d: 删除，删除选择的行；<br>i: 插入， 在当前行上面插入文本；<br>p: 打印，打印选择行数据，通常与sed -n一起使用；<br>s: 替换，替换指定字符串，通常与正则表达式一起使用；</p>\n</blockquote>\n<h2 id=\"2-用法实例\"><a href=\"#2-用法实例\" class=\"headerlink\" title=\"2. 用法实例\"></a>2. 用法实例</h2><h5 id=\"替换操作\"><a href=\"#替换操作\" class=\"headerlink\" title=\"替换操作\"></a>替换操作</h5><p>将file文件中每一行第一个的oldStr替换成newStr</p>\n<blockquote>\n<p>sed ‘s/oldStr/newStr/‘ file   </p>\n</blockquote>\n<p>使用后缀g标记会替换每一行中的所有匹配 </p>\n<blockquote>\n<p>sed ‘s/oldStr/newStr/g’ file </p>\n</blockquote>\n<p>-n选项和p命令一起使用表示只打印那些发生替换的行    </p>\n<blockquote>\n<p>sed -n ‘s/oldStr/newStr/p’ </p>\n</blockquote>\n<p>当需要从第N处匹配开始替换时，可以使用 /Ng</p>\n<blockquote>\n<p>echo testtesttesttest | sed ‘s/test/TEST/2’<br>testTESTtesttest</p>\n</blockquote>\n<h5 id=\"定界符\"><a href=\"#定界符\" class=\"headerlink\" title=\"定界符\"></a>定界符</h5><p>其中 / 在sed中作为定界符使用，也可以使用任意的定界符：</p>\n<blockquote>\n<p>sed ‘s|oldStr|newStr|’ file<br>sed ‘s:oldStr:newStr:’ file   </p>\n</blockquote>\n<p>定界符出现在样式内部时，需要进行转义：</p>\n<blockquote>\n<p>echo /bin | sed ‘s/\\/bin/\\/usr\\/local\\/bin/g’<br>/usr/local/bin</p>\n</blockquote>\n<h5 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h5><p>删除空白行：</p>\n<blockquote>\n<p>sed ‘/^$/d’ file</p>\n</blockquote>\n<p>删除文件的第2行：</p>\n<blockquote>\n<p>sed ‘2d’ file</p>\n</blockquote>\n<p>删除文件的第2行到第5行：</p>\n<blockquote>\n<p>sed ‘2,5d’ file</p>\n</blockquote>\n<p>删除文件中所有开头是test的行：</p>\n<blockquote>\n<p>sed ‘/^test/‘d file</p>\n</blockquote>\n<h5 id=\"多点编辑\"><a href=\"#多点编辑\" class=\"headerlink\" title=\"多点编辑\"></a>多点编辑</h5><p>-e选项允许在同一行里执行多条命令。先删除1至5行，再用test替换TEST：</p>\n<blockquote>\n<p>sed -e ‘1,5d’ -e ‘s/test/TEST/‘ file</p>\n</blockquote>\n<h5 id=\"从文件读入\"><a href=\"#从文件读入\" class=\"headerlink\" title=\"从文件读入\"></a>从文件读入</h5><p>file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面：</p>\n<blockquote>\n<p>sed ‘/test/r file’ filename</p>\n</blockquote>\n<h5 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h5><p>在example中所有包含test的行都被写入file里</p>\n<blockquote>\n<p>sed -n ‘/test/w file’ example</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;sed是stream editor(流编辑器)的缩写，是linux中文本处理非常重要的工具。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”(pattern space)，接着用sed命令处理模式空间中的内容，处理完成后，把缓冲区的内容输出，接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，因为这些都在模式空间处理的。sed可以用来自动编辑一个或多个文件。</p>","more":"<h2 id=\"1-命令格式\"><a href=\"#1-命令格式\" class=\"headerlink\" title=\"1. 命令格式\"></a>1. 命令格式</h2><blockquote>\n<p>sed [options] [command] file(s)</p>\n</blockquote>\n<h5 id=\"option-选项\"><a href=\"#option-选项\" class=\"headerlink\" title=\"[option] 选项\"></a>[option] 选项</h5><blockquote>\n<p>-n: 仅显示处理后的结果；<br>-i: 直接修改读取的文件内容，而不是输出到终端；<br>-e &lt;script&gt;: 以选项中的指定的script来处理输入的文本文件；<br>-f &lt;script file&gt;: 以选项中指定的script文件来处理输入的文本文件；</p>\n</blockquote>\n<h5 id=\"command-命令\"><a href=\"#command-命令\" class=\"headerlink\" title=\"[command] 命令\"></a>[command] 命令</h5><blockquote>\n<p>a: 新增，在当前行下面插入文本；<br>c: 取代， 把选定的行改为新的文本；<br>d: 删除，删除选择的行；<br>i: 插入， 在当前行上面插入文本；<br>p: 打印，打印选择行数据，通常与sed -n一起使用；<br>s: 替换，替换指定字符串，通常与正则表达式一起使用；</p>\n</blockquote>\n<h2 id=\"2-用法实例\"><a href=\"#2-用法实例\" class=\"headerlink\" title=\"2. 用法实例\"></a>2. 用法实例</h2><h5 id=\"替换操作\"><a href=\"#替换操作\" class=\"headerlink\" title=\"替换操作\"></a>替换操作</h5><p>将file文件中每一行第一个的oldStr替换成newStr</p>\n<blockquote>\n<p>sed ‘s/oldStr/newStr/‘ file   </p>\n</blockquote>\n<p>使用后缀g标记会替换每一行中的所有匹配 </p>\n<blockquote>\n<p>sed ‘s/oldStr/newStr/g’ file </p>\n</blockquote>\n<p>-n选项和p命令一起使用表示只打印那些发生替换的行    </p>\n<blockquote>\n<p>sed -n ‘s/oldStr/newStr/p’ </p>\n</blockquote>\n<p>当需要从第N处匹配开始替换时，可以使用 /Ng</p>\n<blockquote>\n<p>echo testtesttesttest | sed ‘s/test/TEST/2’<br>testTESTtesttest</p>\n</blockquote>\n<h5 id=\"定界符\"><a href=\"#定界符\" class=\"headerlink\" title=\"定界符\"></a>定界符</h5><p>其中 / 在sed中作为定界符使用，也可以使用任意的定界符：</p>\n<blockquote>\n<p>sed ‘s|oldStr|newStr|’ file<br>sed ‘s:oldStr:newStr:’ file   </p>\n</blockquote>\n<p>定界符出现在样式内部时，需要进行转义：</p>\n<blockquote>\n<p>echo /bin | sed ‘s/\\/bin/\\/usr\\/local\\/bin/g’<br>/usr/local/bin</p>\n</blockquote>\n<h5 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h5><p>删除空白行：</p>\n<blockquote>\n<p>sed ‘/^$/d’ file</p>\n</blockquote>\n<p>删除文件的第2行：</p>\n<blockquote>\n<p>sed ‘2d’ file</p>\n</blockquote>\n<p>删除文件的第2行到第5行：</p>\n<blockquote>\n<p>sed ‘2,5d’ file</p>\n</blockquote>\n<p>删除文件中所有开头是test的行：</p>\n<blockquote>\n<p>sed ‘/^test/‘d file</p>\n</blockquote>\n<h5 id=\"多点编辑\"><a href=\"#多点编辑\" class=\"headerlink\" title=\"多点编辑\"></a>多点编辑</h5><p>-e选项允许在同一行里执行多条命令。先删除1至5行，再用test替换TEST：</p>\n<blockquote>\n<p>sed -e ‘1,5d’ -e ‘s/test/TEST/‘ file</p>\n</blockquote>\n<h5 id=\"从文件读入\"><a href=\"#从文件读入\" class=\"headerlink\" title=\"从文件读入\"></a>从文件读入</h5><p>file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面：</p>\n<blockquote>\n<p>sed ‘/test/r file’ filename</p>\n</blockquote>\n<h5 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h5><p>在example中所有包含test的行都被写入file里</p>\n<blockquote>\n<p>sed -n ‘/test/w file’ example</p>\n</blockquote>"},{"title":"Python函数参数详解","date":"2018-10-13T14:12:02.000Z","_content":"\n&emsp;&emsp;Python函数定义时参数灵活，使用不同参数的组合不仅可以简化调用者的代码，还可以处理复杂的参数。函数的参数除了有必选参数外，还可以使用默认参数，可变参数，关键字参数和命名关键字参数。\n\n## 1. 位置参数\n定义一个计算x^2的函数，以及一个计算x^n的函数\n<!-- more -->\n```python\ndef calc1(x):\n    return x * x\n\ndef calc2(x, n):\n    s = 1\n    for i in range(n):\n        s *= x\n    return s\n```\n\n对于这两个函数，其参数都是位置参数，同时也是必选参数，调用函数时实参需和形参一一对应，当参数不对应时会引起错误，例如：\n> &gt;&gt;&gt;calc2(2)    \n> Traceback (most recent call last):   \n> File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;     \n> TypeError: calc2() takes exactly 2 arguments (1 given)    \n>     \n> &gt;&gt;&gt;calc2(2, 2, 2)    \n> Traceback (most recent call last):   \n> File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;      \n> TypeError: calc2() takes exactly 2 arguments (3 given)     \n\n## 2. 默认参数\n对于函数calc2，如若函数调用过程中，计算x^2使用的较多，每次调用都要通过calc2(x, 2)来调用，这样就略显繁琐，此时可以通过默认参数来简化函数的调用，改写函数为：\n```python\ndef calc3(x, n = 2):\n    s = 1\n    for i in range(n):\n        s *= x\n    return s\n```\n这样，我们在调用calc3(2)时，就相当于调用calc3(2, 2)，而对于其他次方仍需明确指出n。\n默认参数在使用中应当的注意：位置(必选)参数在前，默认参数在后。\n    \n当有多个默认参数时，既可以按顺序提供默认参数，也可以不按顺序提供默认参数。\n```python\ndef saveInfo(name, gender, age = 23, city = 'HangZhou'):\n    print(name, gender, age, city)\n\nsaveInfo('Alen', 'M', city='Beijing')\n```\n    \n定义默认参数时需要特别注意的一点：**默认参数必须指向不变对象！**\n看如下例子：\n```python\ndef addEnd(L=[]):\n    L.append('END')\n    return L\n```\n> &gt;&gt;&gt;addEnd()   \n> ['END']    \n> &gt;&gt;&gt;addEnd()  \n> ['END', 'END']    \n> &gt;&gt;&gt;addEnd()    \n> ['END', 'END', 'END']     \n\n出现这样的结果是因为：默认参数L仅仅代表[]的一个引用，函数定义时[]就已确定，每次调用addEnd时，使用的都是函数定义时的[]，通过print(id(L))可以看出，每次调用该函数时使用的是同一内存地址的[]。\n```python\ndef addEnd(L=[]):\n    L.append('END')\n    print(id(L))\n    return L\n\naddEnd()\n#4518465224\n#['END']\naddEnd()\n#4518465224\n#['END', 'END']\n```\n为了避免这个问题，可以通过下面的方式，每次调用函数时，都会新建一个[]：\n```python\ndef addEnd(L=None):\n    L = [] if L == None else L\n    L.append('END')\n    print(id(L))\n    return L\n\naddEnd()\n#4518687688\n#['END']\naddEnd()\n#4518688328\n#['END']\n```\n## 3. 可变参数\n可变参数即传入的参数个数是可变的，可以是0个，1个，或多个   \n先定义一下函数，给定一组数字a，b，c...，计算这组数字的平方和a^2 + b^2 + c^2 + ...\n```python\ndef calc(numbers):\n    s = 0\n    for num in numbers:\n        s = s + num * num\n    return s\n```\n该函数在调用时，需先组装一个list或tuple    \n> &gt;&gt;&gt;calc([1, 2, 3])     \n> 14\n> &gt;&gt;&gt;calc([1, 2, 3])     \n> 30\n\n如果利用可变参数，函数的调用可以简化\n```python\ndef calc(*numbers):\n    s = 0\n    for num in numbers:\n        s = s + num * num\n    return s\n\ncalc()\n# 0\ncalc(1, 2, 3)     \n# 14\ncalc(1, 2, 3, 4)\n# 30\n```\n可变参数与list或tuple参数相比，仅仅在参数前面加了个\\*号，\\*的作用是将传入的参数组装成一个tuple\n，如果已经有一个list或tuple，要调用可变参数怎么办呢？\n> &gt;&gt;&gt;nums = [1, 2, 3]     \n> &gt;&gt;&gt;calc(nums[0], nums[1], nums[2])     \n> 14  \n\n这种写法就过于繁琐，针对这种情况，python允许在list或tuple前加一个*号，将list或tuple的元素变成可变参数传入\n> &gt;&gt;&gt;nums = [1, 2, 3]     \n> &gt;&gt;&gt;calc(*nums)       \n> 14    \n\n## 4. 关键字参数\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict    \n定义一个用户注册的函数\n```Python\ndef user(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n\nuser('Bob', 23)          \n# ('name:', 'Bob', 'age:', 23, 'other:', {})\nuser('Alen', 20, gender='M', job='Engineer') \n# ('name:', 'Alen', 'age:', 20, 'other:', {'gender': 'M', 'job': 'Engineer'})\n```\n函数user除了接收必选参数name，age外还接收关键字参数kw，调用该函数时，可以只传入必选参数，也可以传入任意个数的关键字参数，**\\*\\*的作用是将含参数名的参数，组装成一个dict传入kw**。关键字参数可以扩展函数的功能，调用者如果提供更多的信息，我们仍可以接收到。例如当用户注册时，姓名和年龄时必填项，其他是可选项，就可以通过关键字参数来实现。        \n和可变参数类似，当有现成dict时，可通过以下方式简化调用：\n> &gt;&gt;&gt;extra = {'city': 'Beijing', 'job': 'Engineer'}    \n> user('Bob', 23, **extra)    \n> name: Bob age: 23 other: {'city': 'Beijing', 'job': 'Engineer'}     \n\n\\*\\*extra表示把extra这个dict的所有key-value用关键字参数传入到函数的\\*\\*kw参数，kw将获得一个dict。**注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。**\n## 5. 命名关键字参数\n对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数，如果要限制关键字参数的名字，就可以用命名关键字参数。命名关键字参数需要一个特殊分隔符\\*，\\*后面的参数被视为命名关键字参数，例如，只接收city和job作为关键字参数：\n```Python\ndef user(name, age, *, city, job):\n    print('name:', name, 'age:', age, 'city:', city, 'job:', job)\n\nuser('Alen', 20, city='Beijing', job='Engineer') \n# name: Alen age: 20 city: Beijing job: Engineer\n```\n不同于位置参数，命名关键字参数必须传入参数名。如果没有传入参数名，调用将报错：\n> &gt;&gt;&gt;user('Alen', 20, 'Beijing', 'Engineer')    \n> Traceback (most recent call last):    \n>   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;    \n> TypeError: user() takes 2 positional arguments but 4 were given\n\n若函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n```Python\ndef user(name, age, *args, city, job):\n    print(name, age, args, city, job)\n```\n命名关键字参数可以有缺省值，从而简化调用：\n```Python\ndef user(name, age, *, city='Beijing', job):\n    print(name, age, city, job)\n\nuser('Bob', 22, job='Engineer')\n# Bob 22 Beijing Engineer\n```\n## 6. 参数组合\n定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是应注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n定义一个函数，包含上述参数：\n```Python\ndef user(name, age = 20, *args, city = 'Beijing', job, **kw):\n    print(name, age, args, city, job, kw)\n\nuser('Bob', 20, 120, job = 'Engineer', gender = 'M')\n# Bob 20 (120,) Beijing Engineer {'gender': 'M'}\n```\n对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\n> &gt;&gt;&gt;args = ('Bob', 20, 120)     \n> &gt;&gt;&gt;kw = {'job':'Engineer', 'gender':'M'}     \n> &gt;&gt;&gt;user(*args, **kw)     \n> Bob 20 (120,) Beijing Engineer {'gender': 'M'}\n","source":"_posts/python-函数参数.md","raw":"---\ntitle: Python函数参数详解\ndate: 2018-10-13 22:12:02\ntags: [python]\n---\n\n&emsp;&emsp;Python函数定义时参数灵活，使用不同参数的组合不仅可以简化调用者的代码，还可以处理复杂的参数。函数的参数除了有必选参数外，还可以使用默认参数，可变参数，关键字参数和命名关键字参数。\n\n## 1. 位置参数\n定义一个计算x^2的函数，以及一个计算x^n的函数\n<!-- more -->\n```python\ndef calc1(x):\n    return x * x\n\ndef calc2(x, n):\n    s = 1\n    for i in range(n):\n        s *= x\n    return s\n```\n\n对于这两个函数，其参数都是位置参数，同时也是必选参数，调用函数时实参需和形参一一对应，当参数不对应时会引起错误，例如：\n> &gt;&gt;&gt;calc2(2)    \n> Traceback (most recent call last):   \n> File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;     \n> TypeError: calc2() takes exactly 2 arguments (1 given)    \n>     \n> &gt;&gt;&gt;calc2(2, 2, 2)    \n> Traceback (most recent call last):   \n> File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;      \n> TypeError: calc2() takes exactly 2 arguments (3 given)     \n\n## 2. 默认参数\n对于函数calc2，如若函数调用过程中，计算x^2使用的较多，每次调用都要通过calc2(x, 2)来调用，这样就略显繁琐，此时可以通过默认参数来简化函数的调用，改写函数为：\n```python\ndef calc3(x, n = 2):\n    s = 1\n    for i in range(n):\n        s *= x\n    return s\n```\n这样，我们在调用calc3(2)时，就相当于调用calc3(2, 2)，而对于其他次方仍需明确指出n。\n默认参数在使用中应当的注意：位置(必选)参数在前，默认参数在后。\n    \n当有多个默认参数时，既可以按顺序提供默认参数，也可以不按顺序提供默认参数。\n```python\ndef saveInfo(name, gender, age = 23, city = 'HangZhou'):\n    print(name, gender, age, city)\n\nsaveInfo('Alen', 'M', city='Beijing')\n```\n    \n定义默认参数时需要特别注意的一点：**默认参数必须指向不变对象！**\n看如下例子：\n```python\ndef addEnd(L=[]):\n    L.append('END')\n    return L\n```\n> &gt;&gt;&gt;addEnd()   \n> ['END']    \n> &gt;&gt;&gt;addEnd()  \n> ['END', 'END']    \n> &gt;&gt;&gt;addEnd()    \n> ['END', 'END', 'END']     \n\n出现这样的结果是因为：默认参数L仅仅代表[]的一个引用，函数定义时[]就已确定，每次调用addEnd时，使用的都是函数定义时的[]，通过print(id(L))可以看出，每次调用该函数时使用的是同一内存地址的[]。\n```python\ndef addEnd(L=[]):\n    L.append('END')\n    print(id(L))\n    return L\n\naddEnd()\n#4518465224\n#['END']\naddEnd()\n#4518465224\n#['END', 'END']\n```\n为了避免这个问题，可以通过下面的方式，每次调用函数时，都会新建一个[]：\n```python\ndef addEnd(L=None):\n    L = [] if L == None else L\n    L.append('END')\n    print(id(L))\n    return L\n\naddEnd()\n#4518687688\n#['END']\naddEnd()\n#4518688328\n#['END']\n```\n## 3. 可变参数\n可变参数即传入的参数个数是可变的，可以是0个，1个，或多个   \n先定义一下函数，给定一组数字a，b，c...，计算这组数字的平方和a^2 + b^2 + c^2 + ...\n```python\ndef calc(numbers):\n    s = 0\n    for num in numbers:\n        s = s + num * num\n    return s\n```\n该函数在调用时，需先组装一个list或tuple    \n> &gt;&gt;&gt;calc([1, 2, 3])     \n> 14\n> &gt;&gt;&gt;calc([1, 2, 3])     \n> 30\n\n如果利用可变参数，函数的调用可以简化\n```python\ndef calc(*numbers):\n    s = 0\n    for num in numbers:\n        s = s + num * num\n    return s\n\ncalc()\n# 0\ncalc(1, 2, 3)     \n# 14\ncalc(1, 2, 3, 4)\n# 30\n```\n可变参数与list或tuple参数相比，仅仅在参数前面加了个\\*号，\\*的作用是将传入的参数组装成一个tuple\n，如果已经有一个list或tuple，要调用可变参数怎么办呢？\n> &gt;&gt;&gt;nums = [1, 2, 3]     \n> &gt;&gt;&gt;calc(nums[0], nums[1], nums[2])     \n> 14  \n\n这种写法就过于繁琐，针对这种情况，python允许在list或tuple前加一个*号，将list或tuple的元素变成可变参数传入\n> &gt;&gt;&gt;nums = [1, 2, 3]     \n> &gt;&gt;&gt;calc(*nums)       \n> 14    \n\n## 4. 关键字参数\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict    \n定义一个用户注册的函数\n```Python\ndef user(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n\nuser('Bob', 23)          \n# ('name:', 'Bob', 'age:', 23, 'other:', {})\nuser('Alen', 20, gender='M', job='Engineer') \n# ('name:', 'Alen', 'age:', 20, 'other:', {'gender': 'M', 'job': 'Engineer'})\n```\n函数user除了接收必选参数name，age外还接收关键字参数kw，调用该函数时，可以只传入必选参数，也可以传入任意个数的关键字参数，**\\*\\*的作用是将含参数名的参数，组装成一个dict传入kw**。关键字参数可以扩展函数的功能，调用者如果提供更多的信息，我们仍可以接收到。例如当用户注册时，姓名和年龄时必填项，其他是可选项，就可以通过关键字参数来实现。        \n和可变参数类似，当有现成dict时，可通过以下方式简化调用：\n> &gt;&gt;&gt;extra = {'city': 'Beijing', 'job': 'Engineer'}    \n> user('Bob', 23, **extra)    \n> name: Bob age: 23 other: {'city': 'Beijing', 'job': 'Engineer'}     \n\n\\*\\*extra表示把extra这个dict的所有key-value用关键字参数传入到函数的\\*\\*kw参数，kw将获得一个dict。**注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。**\n## 5. 命名关键字参数\n对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数，如果要限制关键字参数的名字，就可以用命名关键字参数。命名关键字参数需要一个特殊分隔符\\*，\\*后面的参数被视为命名关键字参数，例如，只接收city和job作为关键字参数：\n```Python\ndef user(name, age, *, city, job):\n    print('name:', name, 'age:', age, 'city:', city, 'job:', job)\n\nuser('Alen', 20, city='Beijing', job='Engineer') \n# name: Alen age: 20 city: Beijing job: Engineer\n```\n不同于位置参数，命名关键字参数必须传入参数名。如果没有传入参数名，调用将报错：\n> &gt;&gt;&gt;user('Alen', 20, 'Beijing', 'Engineer')    \n> Traceback (most recent call last):    \n>   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;    \n> TypeError: user() takes 2 positional arguments but 4 were given\n\n若函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n```Python\ndef user(name, age, *args, city, job):\n    print(name, age, args, city, job)\n```\n命名关键字参数可以有缺省值，从而简化调用：\n```Python\ndef user(name, age, *, city='Beijing', job):\n    print(name, age, city, job)\n\nuser('Bob', 22, job='Engineer')\n# Bob 22 Beijing Engineer\n```\n## 6. 参数组合\n定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是应注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n定义一个函数，包含上述参数：\n```Python\ndef user(name, age = 20, *args, city = 'Beijing', job, **kw):\n    print(name, age, args, city, job, kw)\n\nuser('Bob', 20, 120, job = 'Engineer', gender = 'M')\n# Bob 20 (120,) Beijing Engineer {'gender': 'M'}\n```\n对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\n> &gt;&gt;&gt;args = ('Bob', 20, 120)     \n> &gt;&gt;&gt;kw = {'job':'Engineer', 'gender':'M'}     \n> &gt;&gt;&gt;user(*args, **kw)     \n> Bob 20 (120,) Beijing Engineer {'gender': 'M'}\n","slug":"python-函数参数","published":1,"updated":"2020-06-18T15:01:02.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbllvcmm0002v7gp6psnqgaf","content":"<p>&emsp;&emsp;Python函数定义时参数灵活，使用不同参数的组合不仅可以简化调用者的代码，还可以处理复杂的参数。函数的参数除了有必选参数外，还可以使用默认参数，可变参数，关键字参数和命名关键字参数。</p>\n<h2 id=\"1-位置参数\"><a href=\"#1-位置参数\" class=\"headerlink\" title=\"1. 位置参数\"></a>1. 位置参数</h2><p>定义一个计算x^2的函数，以及一个计算x^n的函数<br><a id=\"more\"></a><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc1</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc2</span><span class=\"params\">(x, n)</span>:</span></span><br><span class=\"line\">    s = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        s *= x</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br></pre></td></tr></table></figure></p>\n<p>对于这两个函数，其参数都是位置参数，同时也是必选参数，调用函数时实参需和形参一一对应，当参数不对应时会引起错误，例如：</p>\n<blockquote>\n<p>&gt;&gt;&gt;calc2(2)<br>Traceback (most recent call last):<br>File “&lt;stdin&gt;”, line 1, in &lt;module&gt;<br>TypeError: calc2() takes exactly 2 arguments (1 given)    </p>\n<p>&gt;&gt;&gt;calc2(2, 2, 2)<br>Traceback (most recent call last):<br>File “&lt;stdin&gt;”, line 1, in &lt;module&gt;<br>TypeError: calc2() takes exactly 2 arguments (3 given)     </p>\n</blockquote>\n<h2 id=\"2-默认参数\"><a href=\"#2-默认参数\" class=\"headerlink\" title=\"2. 默认参数\"></a>2. 默认参数</h2><p>对于函数calc2，如若函数调用过程中，计算x^2使用的较多，每次调用都要通过calc2(x, 2)来调用，这样就略显繁琐，此时可以通过默认参数来简化函数的调用，改写函数为：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc3</span><span class=\"params\">(x, n = <span class=\"number\">2</span>)</span>:</span></span><br><span class=\"line\">    s = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        s *= x</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br></pre></td></tr></table></figure></p>\n<p>这样，我们在调用calc3(2)时，就相当于调用calc3(2, 2)，而对于其他次方仍需明确指出n。<br>默认参数在使用中应当的注意：位置(必选)参数在前，默认参数在后。</p>\n<p>当有多个默认参数时，既可以按顺序提供默认参数，也可以不按顺序提供默认参数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">saveInfo</span><span class=\"params\">(name, gender, age = <span class=\"number\">23</span>, city = <span class=\"string\">'HangZhou'</span>)</span>:</span></span><br><span class=\"line\">    print(name, gender, age, city)</span><br><span class=\"line\"></span><br><span class=\"line\">saveInfo(<span class=\"string\">'Alen'</span>, <span class=\"string\">'M'</span>, city=<span class=\"string\">'Beijing'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>定义默认参数时需要特别注意的一点：<strong>默认参数必须指向不变对象！</strong><br>看如下例子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addEnd</span><span class=\"params\">(L=[])</span>:</span></span><br><span class=\"line\">    L.append(<span class=\"string\">'END'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>&gt;&gt;&gt;addEnd()<br>[‘END’]<br>&gt;&gt;&gt;addEnd()<br>[‘END’, ‘END’]<br>&gt;&gt;&gt;addEnd()<br>[‘END’, ‘END’, ‘END’]     </p>\n</blockquote>\n<p>出现这样的结果是因为：默认参数L仅仅代表[]的一个引用，函数定义时[]就已确定，每次调用addEnd时，使用的都是函数定义时的[]，通过print(id(L))可以看出，每次调用该函数时使用的是同一内存地址的[]。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addEnd</span><span class=\"params\">(L=[])</span>:</span></span><br><span class=\"line\">    L.append(<span class=\"string\">'END'</span>)</span><br><span class=\"line\">    print(id(L))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L</span><br><span class=\"line\"></span><br><span class=\"line\">addEnd()</span><br><span class=\"line\"><span class=\"comment\">#4518465224</span></span><br><span class=\"line\"><span class=\"comment\">#['END']</span></span><br><span class=\"line\">addEnd()</span><br><span class=\"line\"><span class=\"comment\">#4518465224</span></span><br><span class=\"line\"><span class=\"comment\">#['END', 'END']</span></span><br></pre></td></tr></table></figure></p>\n<p>为了避免这个问题，可以通过下面的方式，每次调用函数时，都会新建一个[]：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addEnd</span><span class=\"params\">(L=None)</span>:</span></span><br><span class=\"line\">    L = [] <span class=\"keyword\">if</span> L == <span class=\"literal\">None</span> <span class=\"keyword\">else</span> L</span><br><span class=\"line\">    L.append(<span class=\"string\">'END'</span>)</span><br><span class=\"line\">    print(id(L))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L</span><br><span class=\"line\"></span><br><span class=\"line\">addEnd()</span><br><span class=\"line\"><span class=\"comment\">#4518687688</span></span><br><span class=\"line\"><span class=\"comment\">#['END']</span></span><br><span class=\"line\">addEnd()</span><br><span class=\"line\"><span class=\"comment\">#4518688328</span></span><br><span class=\"line\"><span class=\"comment\">#['END']</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-可变参数\"><a href=\"#3-可变参数\" class=\"headerlink\" title=\"3. 可变参数\"></a>3. 可变参数</h2><p>可变参数即传入的参数个数是可变的，可以是0个，1个，或多个<br>先定义一下函数，给定一组数字a，b，c…，计算这组数字的平方和a^2 + b^2 + c^2 + …<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(numbers)</span>:</span></span><br><span class=\"line\">    s = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> numbers:</span><br><span class=\"line\">        s = s + num * num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br></pre></td></tr></table></figure></p>\n<p>该函数在调用时，需先组装一个list或tuple    </p>\n<blockquote>\n<p>&gt;&gt;&gt;calc([1, 2, 3])<br>14<br>&gt;&gt;&gt;calc([1, 2, 3])<br>30</p>\n</blockquote>\n<p>如果利用可变参数，函数的调用可以简化<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(*numbers)</span>:</span></span><br><span class=\"line\">    s = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> numbers:</span><br><span class=\"line\">        s = s + num * num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\">calc()</span><br><span class=\"line\"><span class=\"comment\"># 0</span></span><br><span class=\"line\">calc(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)     </span><br><span class=\"line\"><span class=\"comment\"># 14</span></span><br><span class=\"line\">calc(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\"># 30</span></span><br></pre></td></tr></table></figure></p>\n<p>可变参数与list或tuple参数相比，仅仅在参数前面加了个*号，*的作用是将传入的参数组装成一个tuple<br>，如果已经有一个list或tuple，要调用可变参数怎么办呢？</p>\n<blockquote>\n<p>&gt;&gt;&gt;nums = [1, 2, 3]<br>&gt;&gt;&gt;calc(nums[0], nums[1], nums[2])<br>14  </p>\n</blockquote>\n<p>这种写法就过于繁琐，针对这种情况，python允许在list或tuple前加一个*号，将list或tuple的元素变成可变参数传入</p>\n<blockquote>\n<p>&gt;&gt;&gt;nums = [1, 2, 3]<br>&gt;&gt;&gt;calc(*nums)<br>14    </p>\n</blockquote>\n<h2 id=\"4-关键字参数\"><a href=\"#4-关键字参数\" class=\"headerlink\" title=\"4. 关键字参数\"></a>4. 关键字参数</h2><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict<br>定义一个用户注册的函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age, **kw)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw)</span><br><span class=\"line\"></span><br><span class=\"line\">user(<span class=\"string\">'Bob'</span>, <span class=\"number\">23</span>)          </span><br><span class=\"line\"><span class=\"comment\"># ('name:', 'Bob', 'age:', 23, 'other:', &#123;&#125;)</span></span><br><span class=\"line\">user(<span class=\"string\">'Alen'</span>, <span class=\"number\">20</span>, gender=<span class=\"string\">'M'</span>, job=<span class=\"string\">'Engineer'</span>) </span><br><span class=\"line\"><span class=\"comment\"># ('name:', 'Alen', 'age:', 20, 'other:', &#123;'gender': 'M', 'job': 'Engineer'&#125;)</span></span><br></pre></td></tr></table></figure></p>\n<p>函数user除了接收必选参数name，age外还接收关键字参数kw，调用该函数时，可以只传入必选参数，也可以传入任意个数的关键字参数，<strong>**的作用是将含参数名的参数，组装成一个dict传入kw</strong>。关键字参数可以扩展函数的功能，调用者如果提供更多的信息，我们仍可以接收到。例如当用户注册时，姓名和年龄时必填项，其他是可选项，就可以通过关键字参数来实现。<br>和可变参数类似，当有现成dict时，可通过以下方式简化调用：</p>\n<blockquote>\n<p>&gt;&gt;&gt;extra = {‘city’: ‘Beijing’, ‘job’: ‘Engineer’}<br>user(‘Bob’, 23, **extra)<br>name: Bob age: 23 other: {‘city’: ‘Beijing’, ‘job’: ‘Engineer’}     </p>\n</blockquote>\n<p>**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict。<strong>注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</strong></p>\n<h2 id=\"5-命名关键字参数\"><a href=\"#5-命名关键字参数\" class=\"headerlink\" title=\"5. 命名关键字参数\"></a>5. 命名关键字参数</h2><p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数，如果要限制关键字参数的名字，就可以用命名关键字参数。命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数，例如，只接收city和job作为关键字参数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age, *, city, job)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'city:'</span>, city, <span class=\"string\">'job:'</span>, job)</span><br><span class=\"line\"></span><br><span class=\"line\">user(<span class=\"string\">'Alen'</span>, <span class=\"number\">20</span>, city=<span class=\"string\">'Beijing'</span>, job=<span class=\"string\">'Engineer'</span>) </span><br><span class=\"line\"><span class=\"comment\"># name: Alen age: 20 city: Beijing job: Engineer</span></span><br></pre></td></tr></table></figure></p>\n<p>不同于位置参数，命名关键字参数必须传入参数名。如果没有传入参数名，调用将报错：</p>\n<blockquote>\n<p>&gt;&gt;&gt;user(‘Alen’, 20, ‘Beijing’, ‘Engineer’)<br>Traceback (most recent call last):<br>  File “&lt;stdin&gt;”, line 1, in &lt;module&gt;<br>TypeError: user() takes 2 positional arguments but 4 were given</p>\n</blockquote>\n<p>若函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age, *args, city, job)</span>:</span></span><br><span class=\"line\">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure></p>\n<p>命名关键字参数可以有缺省值，从而简化调用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age, *, city=<span class=\"string\">'Beijing'</span>, job)</span>:</span></span><br><span class=\"line\">    print(name, age, city, job)</span><br><span class=\"line\"></span><br><span class=\"line\">user(<span class=\"string\">'Bob'</span>, <span class=\"number\">22</span>, job=<span class=\"string\">'Engineer'</span>)</span><br><span class=\"line\"><span class=\"comment\"># Bob 22 Beijing Engineer</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-参数组合\"><a href=\"#6-参数组合\" class=\"headerlink\" title=\"6. 参数组合\"></a>6. 参数组合</h2><p>定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是应注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。<br>定义一个函数，包含上述参数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age = <span class=\"number\">20</span>, *args, city = <span class=\"string\">'Beijing'</span>, job, **kw)</span>:</span></span><br><span class=\"line\">    print(name, age, args, city, job, kw)</span><br><span class=\"line\"></span><br><span class=\"line\">user(<span class=\"string\">'Bob'</span>, <span class=\"number\">20</span>, <span class=\"number\">120</span>, job = <span class=\"string\">'Engineer'</span>, gender = <span class=\"string\">'M'</span>)</span><br><span class=\"line\"><span class=\"comment\"># Bob 20 (120,) Beijing Engineer &#123;'gender': 'M'&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。</p>\n<blockquote>\n<p>&gt;&gt;&gt;args = (‘Bob’, 20, 120)<br>&gt;&gt;&gt;kw = {‘job’:’Engineer’, ‘gender’:’M’}<br>&gt;&gt;&gt;user(*args, **kw)<br>Bob 20 (120,) Beijing Engineer {‘gender’: ‘M’}</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;Python函数定义时参数灵活，使用不同参数的组合不仅可以简化调用者的代码，还可以处理复杂的参数。函数的参数除了有必选参数外，还可以使用默认参数，可变参数，关键字参数和命名关键字参数。</p>\n<h2 id=\"1-位置参数\"><a href=\"#1-位置参数\" class=\"headerlink\" title=\"1. 位置参数\"></a>1. 位置参数</h2><p>定义一个计算x^2的函数，以及一个计算x^n的函数<br>","more":"<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc1</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc2</span><span class=\"params\">(x, n)</span>:</span></span><br><span class=\"line\">    s = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        s *= x</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br></pre></td></tr></table></figure></p>\n<p>对于这两个函数，其参数都是位置参数，同时也是必选参数，调用函数时实参需和形参一一对应，当参数不对应时会引起错误，例如：</p>\n<blockquote>\n<p>&gt;&gt;&gt;calc2(2)<br>Traceback (most recent call last):<br>File “&lt;stdin&gt;”, line 1, in &lt;module&gt;<br>TypeError: calc2() takes exactly 2 arguments (1 given)    </p>\n<p>&gt;&gt;&gt;calc2(2, 2, 2)<br>Traceback (most recent call last):<br>File “&lt;stdin&gt;”, line 1, in &lt;module&gt;<br>TypeError: calc2() takes exactly 2 arguments (3 given)     </p>\n</blockquote>\n<h2 id=\"2-默认参数\"><a href=\"#2-默认参数\" class=\"headerlink\" title=\"2. 默认参数\"></a>2. 默认参数</h2><p>对于函数calc2，如若函数调用过程中，计算x^2使用的较多，每次调用都要通过calc2(x, 2)来调用，这样就略显繁琐，此时可以通过默认参数来简化函数的调用，改写函数为：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc3</span><span class=\"params\">(x, n = <span class=\"number\">2</span>)</span>:</span></span><br><span class=\"line\">    s = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">        s *= x</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br></pre></td></tr></table></figure></p>\n<p>这样，我们在调用calc3(2)时，就相当于调用calc3(2, 2)，而对于其他次方仍需明确指出n。<br>默认参数在使用中应当的注意：位置(必选)参数在前，默认参数在后。</p>\n<p>当有多个默认参数时，既可以按顺序提供默认参数，也可以不按顺序提供默认参数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">saveInfo</span><span class=\"params\">(name, gender, age = <span class=\"number\">23</span>, city = <span class=\"string\">'HangZhou'</span>)</span>:</span></span><br><span class=\"line\">    print(name, gender, age, city)</span><br><span class=\"line\"></span><br><span class=\"line\">saveInfo(<span class=\"string\">'Alen'</span>, <span class=\"string\">'M'</span>, city=<span class=\"string\">'Beijing'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>定义默认参数时需要特别注意的一点：<strong>默认参数必须指向不变对象！</strong><br>看如下例子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addEnd</span><span class=\"params\">(L=[])</span>:</span></span><br><span class=\"line\">    L.append(<span class=\"string\">'END'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>&gt;&gt;&gt;addEnd()<br>[‘END’]<br>&gt;&gt;&gt;addEnd()<br>[‘END’, ‘END’]<br>&gt;&gt;&gt;addEnd()<br>[‘END’, ‘END’, ‘END’]     </p>\n</blockquote>\n<p>出现这样的结果是因为：默认参数L仅仅代表[]的一个引用，函数定义时[]就已确定，每次调用addEnd时，使用的都是函数定义时的[]，通过print(id(L))可以看出，每次调用该函数时使用的是同一内存地址的[]。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addEnd</span><span class=\"params\">(L=[])</span>:</span></span><br><span class=\"line\">    L.append(<span class=\"string\">'END'</span>)</span><br><span class=\"line\">    print(id(L))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L</span><br><span class=\"line\"></span><br><span class=\"line\">addEnd()</span><br><span class=\"line\"><span class=\"comment\">#4518465224</span></span><br><span class=\"line\"><span class=\"comment\">#['END']</span></span><br><span class=\"line\">addEnd()</span><br><span class=\"line\"><span class=\"comment\">#4518465224</span></span><br><span class=\"line\"><span class=\"comment\">#['END', 'END']</span></span><br></pre></td></tr></table></figure></p>\n<p>为了避免这个问题，可以通过下面的方式，每次调用函数时，都会新建一个[]：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addEnd</span><span class=\"params\">(L=None)</span>:</span></span><br><span class=\"line\">    L = [] <span class=\"keyword\">if</span> L == <span class=\"literal\">None</span> <span class=\"keyword\">else</span> L</span><br><span class=\"line\">    L.append(<span class=\"string\">'END'</span>)</span><br><span class=\"line\">    print(id(L))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L</span><br><span class=\"line\"></span><br><span class=\"line\">addEnd()</span><br><span class=\"line\"><span class=\"comment\">#4518687688</span></span><br><span class=\"line\"><span class=\"comment\">#['END']</span></span><br><span class=\"line\">addEnd()</span><br><span class=\"line\"><span class=\"comment\">#4518688328</span></span><br><span class=\"line\"><span class=\"comment\">#['END']</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-可变参数\"><a href=\"#3-可变参数\" class=\"headerlink\" title=\"3. 可变参数\"></a>3. 可变参数</h2><p>可变参数即传入的参数个数是可变的，可以是0个，1个，或多个<br>先定义一下函数，给定一组数字a，b，c…，计算这组数字的平方和a^2 + b^2 + c^2 + …<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(numbers)</span>:</span></span><br><span class=\"line\">    s = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> numbers:</span><br><span class=\"line\">        s = s + num * num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br></pre></td></tr></table></figure></p>\n<p>该函数在调用时，需先组装一个list或tuple    </p>\n<blockquote>\n<p>&gt;&gt;&gt;calc([1, 2, 3])<br>14<br>&gt;&gt;&gt;calc([1, 2, 3])<br>30</p>\n</blockquote>\n<p>如果利用可变参数，函数的调用可以简化<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(*numbers)</span>:</span></span><br><span class=\"line\">    s = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> numbers:</span><br><span class=\"line\">        s = s + num * num</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\">calc()</span><br><span class=\"line\"><span class=\"comment\"># 0</span></span><br><span class=\"line\">calc(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)     </span><br><span class=\"line\"><span class=\"comment\"># 14</span></span><br><span class=\"line\">calc(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\"># 30</span></span><br></pre></td></tr></table></figure></p>\n<p>可变参数与list或tuple参数相比，仅仅在参数前面加了个*号，*的作用是将传入的参数组装成一个tuple<br>，如果已经有一个list或tuple，要调用可变参数怎么办呢？</p>\n<blockquote>\n<p>&gt;&gt;&gt;nums = [1, 2, 3]<br>&gt;&gt;&gt;calc(nums[0], nums[1], nums[2])<br>14  </p>\n</blockquote>\n<p>这种写法就过于繁琐，针对这种情况，python允许在list或tuple前加一个*号，将list或tuple的元素变成可变参数传入</p>\n<blockquote>\n<p>&gt;&gt;&gt;nums = [1, 2, 3]<br>&gt;&gt;&gt;calc(*nums)<br>14    </p>\n</blockquote>\n<h2 id=\"4-关键字参数\"><a href=\"#4-关键字参数\" class=\"headerlink\" title=\"4. 关键字参数\"></a>4. 关键字参数</h2><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict<br>定义一个用户注册的函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age, **kw)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw)</span><br><span class=\"line\"></span><br><span class=\"line\">user(<span class=\"string\">'Bob'</span>, <span class=\"number\">23</span>)          </span><br><span class=\"line\"><span class=\"comment\"># ('name:', 'Bob', 'age:', 23, 'other:', &#123;&#125;)</span></span><br><span class=\"line\">user(<span class=\"string\">'Alen'</span>, <span class=\"number\">20</span>, gender=<span class=\"string\">'M'</span>, job=<span class=\"string\">'Engineer'</span>) </span><br><span class=\"line\"><span class=\"comment\"># ('name:', 'Alen', 'age:', 20, 'other:', &#123;'gender': 'M', 'job': 'Engineer'&#125;)</span></span><br></pre></td></tr></table></figure></p>\n<p>函数user除了接收必选参数name，age外还接收关键字参数kw，调用该函数时，可以只传入必选参数，也可以传入任意个数的关键字参数，<strong>**的作用是将含参数名的参数，组装成一个dict传入kw</strong>。关键字参数可以扩展函数的功能，调用者如果提供更多的信息，我们仍可以接收到。例如当用户注册时，姓名和年龄时必填项，其他是可选项，就可以通过关键字参数来实现。<br>和可变参数类似，当有现成dict时，可通过以下方式简化调用：</p>\n<blockquote>\n<p>&gt;&gt;&gt;extra = {‘city’: ‘Beijing’, ‘job’: ‘Engineer’}<br>user(‘Bob’, 23, **extra)<br>name: Bob age: 23 other: {‘city’: ‘Beijing’, ‘job’: ‘Engineer’}     </p>\n</blockquote>\n<p>**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict。<strong>注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</strong></p>\n<h2 id=\"5-命名关键字参数\"><a href=\"#5-命名关键字参数\" class=\"headerlink\" title=\"5. 命名关键字参数\"></a>5. 命名关键字参数</h2><p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数，如果要限制关键字参数的名字，就可以用命名关键字参数。命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数，例如，只接收city和job作为关键字参数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age, *, city, job)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'city:'</span>, city, <span class=\"string\">'job:'</span>, job)</span><br><span class=\"line\"></span><br><span class=\"line\">user(<span class=\"string\">'Alen'</span>, <span class=\"number\">20</span>, city=<span class=\"string\">'Beijing'</span>, job=<span class=\"string\">'Engineer'</span>) </span><br><span class=\"line\"><span class=\"comment\"># name: Alen age: 20 city: Beijing job: Engineer</span></span><br></pre></td></tr></table></figure></p>\n<p>不同于位置参数，命名关键字参数必须传入参数名。如果没有传入参数名，调用将报错：</p>\n<blockquote>\n<p>&gt;&gt;&gt;user(‘Alen’, 20, ‘Beijing’, ‘Engineer’)<br>Traceback (most recent call last):<br>  File “&lt;stdin&gt;”, line 1, in &lt;module&gt;<br>TypeError: user() takes 2 positional arguments but 4 were given</p>\n</blockquote>\n<p>若函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age, *args, city, job)</span>:</span></span><br><span class=\"line\">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure></p>\n<p>命名关键字参数可以有缺省值，从而简化调用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age, *, city=<span class=\"string\">'Beijing'</span>, job)</span>:</span></span><br><span class=\"line\">    print(name, age, city, job)</span><br><span class=\"line\"></span><br><span class=\"line\">user(<span class=\"string\">'Bob'</span>, <span class=\"number\">22</span>, job=<span class=\"string\">'Engineer'</span>)</span><br><span class=\"line\"><span class=\"comment\"># Bob 22 Beijing Engineer</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-参数组合\"><a href=\"#6-参数组合\" class=\"headerlink\" title=\"6. 参数组合\"></a>6. 参数组合</h2><p>定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是应注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。<br>定义一个函数，包含上述参数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">user</span><span class=\"params\">(name, age = <span class=\"number\">20</span>, *args, city = <span class=\"string\">'Beijing'</span>, job, **kw)</span>:</span></span><br><span class=\"line\">    print(name, age, args, city, job, kw)</span><br><span class=\"line\"></span><br><span class=\"line\">user(<span class=\"string\">'Bob'</span>, <span class=\"number\">20</span>, <span class=\"number\">120</span>, job = <span class=\"string\">'Engineer'</span>, gender = <span class=\"string\">'M'</span>)</span><br><span class=\"line\"><span class=\"comment\"># Bob 20 (120,) Beijing Engineer &#123;'gender': 'M'&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。</p>\n<blockquote>\n<p>&gt;&gt;&gt;args = (‘Bob’, 20, 120)<br>&gt;&gt;&gt;kw = {‘job’:’Engineer’, ‘gender’:’M’}<br>&gt;&gt;&gt;user(*args, **kw)<br>Bob 20 (120,) Beijing Engineer {‘gender’: ‘M’}</p>\n</blockquote>"},{"title":"Python迭代器生成器","date":"2018-10-13T14:12:02.000Z","_content":"\n&emsp;&emsp;在学习python数据结构的过程中，可迭代对象，迭代器，生成器这些概念参杂在一起，难免让初学者一头雾水，今天就来捋捋这些概览。\n\n## 1. 可迭代对象(iterable)\n什么是可迭代对象，通俗的讲就是可以直接通过for循环遍历的对象就可称为可迭代对象Iterable，可以使用isinstance()判断一个对象是否是Iterable对象：\n<!-- more -->\n>&gt;&gt;&gt;from collections import Iterable  \n>&gt;&gt;&gt;isinstance([], Iterable)  \n>True  \n>&gt;&gt;&gt;isinstance({}, Iterable)  \n>True   \n>&gt;&gt;&gt;isinstance('123', Iterable)   \n>True  \n>&gt;&gt;&gt;isinstance(123, Iterable)   \n>False   \n\n可迭代对象并不指某种具体的数据类型，list, dict, set, str都是迭代对象，再比如打开状态的files，sockets也是可迭代对象，可迭代对象是指代对象的一种属性，代表该对象是可迭代的。可迭代对象实现了\\_\\_iter\\_\\_方法，该方法返回一个迭代器对象。\n\n## 2. 迭代器(iterator)\n任何实现了\\_\\_iter\\_\\_和\\_\\_next\\_\\_方法的对象都是迭代器（python2是实现\\_\\_iter\\_\\_和next方法），\\_\\_iter\\_\\_返回迭代器自身，\\_\\_next\\_\\_返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常。可以使用isinstance()判断一个对象是否是Iterator对象：\n>&gt;&gt;&gt;from collections import Iterator  \n>&gt;&gt;&gt;isinstance([], Iterator)  \n>False  \n>&gt;&gt;&gt;isinstance({}, Iterator)  \n>False   \n>&gt;&gt;&gt;isinstance('123', Iterator)   \n>False  \n>&gt;&gt;&gt;isinstance((x for x in range(10)), Iterator)    \n>True  \n\n其中(x for x in range(10))是生成器表达式，它返回的是一个生成器对象，不同于列表生成式[x for x in range(10)]返回一个list对象。生成器对象都是迭代器对象，但list, dict, str虽然是可迭代对象，但不是迭代器对象，可以使用iter()将list, dict, str等可迭代对象变成迭代器对象。\n\n>&gt;&gt;&gt;isinstance(iter([]), Iterator)  \n>True   \n>&gt;&gt;&gt;isinstance(iter('123'), Iterator)  \n>True   \n\npython的迭代器对象表示一个数据流，可以将这个数据流看作一个有序序列，但我们并不知道序列的长度，只能不断通过调用next()函数实现按需计算下一个数据，因此迭代器的计算是惰性的，只有在需要返回下一个数据时它才计算，迭代器的这种特性可以大大减少内存的开销，迭代器对象甚至可以表示一个无限大的数据流，而让list, dict或者str存储一个无限大的数据流是不可能的。\n\n下面我们通过迭代器来实现斐波那契数列：\n```python\nfrom collections import Iterable\nfrom collections import Iterator\n\nclass Fib:\n    def __init__(self, max):\n        self.n, self.max = 0, max\n        self.a, self.b = 0, 1\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.n < self.max:\n            self.n += 1\n            self.a, self.b = self.b, self.a + self.b\n            return self.a\n        else:\n            raise StopIteration\n\nif __name__ == '__main__':\n    fib = Fib(10)\n    print(isinstance(fib, Iterable)) # True\n    print(isinstance(fib, Iterator)) # True\n    print([e for e in fib]) # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n```\n\nFib既是一个可迭代对象（因为它实现了\\_\\_iter\\_\\_方法），又是一个迭代器（因为实现了\\_\\_next\\_\\_方法）。实例变量a和b用于维护迭代器内部的状态。每次调用next()方法的时候做两件事：\n为下一次调用next()方法修改状态，为当前这次调用生成返回结果。    \n\n**迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。**\n\n\n## 3. 生成器(generator)\n生成器是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写\\_\\_iter\\_\\_()和\\_\\_next\\_\\_()方法了，只需要一个yiled关键字。 \n\n用生成器来实现斐波那契数列的例子是：\n```python\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        n = n + 1\n        a, b = b, b + a\n        yield a\n\nf = fib(10)\nprint(f) # <generator object fib at 0x10d8cf888>\nprint([e for e in f])   # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n```\nfib函数中的yield关键字，将该函数变成了一个生成器，当执行f=fib(10)返回的是一个生成器对象，此时函数中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码，在每次调用next()方法时，遇到yield语句返回值并中断，再次执行时从上次返回的yield语句处继续执行。\n生成器是python非常强大的特性，相比其他容器对象它更加节省内存，同时使用更少的代码，使你的代码更加的优雅，凡事以下结构都可以通过生成器重构：\n```python\ndef fun():\n    result = []\n    for ... in ...:\n        result.append(x)\n    return result\n\ndef fun_gen():\n    for ... in ...:\n        yield x\n```\n\n## 4. 总结\n1. 可迭代对象实现了\\_\\_iter\\_\\_方法，该方法返回一个迭代器对象。\n2. 迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了\\_\\_next\\_\\_和\\_\\_iter\\_\\_方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。\n3. 生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。\n","source":"_posts/python-生成器迭代器.md","raw":"---\ntitle: Python迭代器生成器\ndate: 2018-10-13 22:12:02\ntags: [python]\n---\n\n&emsp;&emsp;在学习python数据结构的过程中，可迭代对象，迭代器，生成器这些概念参杂在一起，难免让初学者一头雾水，今天就来捋捋这些概览。\n\n## 1. 可迭代对象(iterable)\n什么是可迭代对象，通俗的讲就是可以直接通过for循环遍历的对象就可称为可迭代对象Iterable，可以使用isinstance()判断一个对象是否是Iterable对象：\n<!-- more -->\n>&gt;&gt;&gt;from collections import Iterable  \n>&gt;&gt;&gt;isinstance([], Iterable)  \n>True  \n>&gt;&gt;&gt;isinstance({}, Iterable)  \n>True   \n>&gt;&gt;&gt;isinstance('123', Iterable)   \n>True  \n>&gt;&gt;&gt;isinstance(123, Iterable)   \n>False   \n\n可迭代对象并不指某种具体的数据类型，list, dict, set, str都是迭代对象，再比如打开状态的files，sockets也是可迭代对象，可迭代对象是指代对象的一种属性，代表该对象是可迭代的。可迭代对象实现了\\_\\_iter\\_\\_方法，该方法返回一个迭代器对象。\n\n## 2. 迭代器(iterator)\n任何实现了\\_\\_iter\\_\\_和\\_\\_next\\_\\_方法的对象都是迭代器（python2是实现\\_\\_iter\\_\\_和next方法），\\_\\_iter\\_\\_返回迭代器自身，\\_\\_next\\_\\_返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常。可以使用isinstance()判断一个对象是否是Iterator对象：\n>&gt;&gt;&gt;from collections import Iterator  \n>&gt;&gt;&gt;isinstance([], Iterator)  \n>False  \n>&gt;&gt;&gt;isinstance({}, Iterator)  \n>False   \n>&gt;&gt;&gt;isinstance('123', Iterator)   \n>False  \n>&gt;&gt;&gt;isinstance((x for x in range(10)), Iterator)    \n>True  \n\n其中(x for x in range(10))是生成器表达式，它返回的是一个生成器对象，不同于列表生成式[x for x in range(10)]返回一个list对象。生成器对象都是迭代器对象，但list, dict, str虽然是可迭代对象，但不是迭代器对象，可以使用iter()将list, dict, str等可迭代对象变成迭代器对象。\n\n>&gt;&gt;&gt;isinstance(iter([]), Iterator)  \n>True   \n>&gt;&gt;&gt;isinstance(iter('123'), Iterator)  \n>True   \n\npython的迭代器对象表示一个数据流，可以将这个数据流看作一个有序序列，但我们并不知道序列的长度，只能不断通过调用next()函数实现按需计算下一个数据，因此迭代器的计算是惰性的，只有在需要返回下一个数据时它才计算，迭代器的这种特性可以大大减少内存的开销，迭代器对象甚至可以表示一个无限大的数据流，而让list, dict或者str存储一个无限大的数据流是不可能的。\n\n下面我们通过迭代器来实现斐波那契数列：\n```python\nfrom collections import Iterable\nfrom collections import Iterator\n\nclass Fib:\n    def __init__(self, max):\n        self.n, self.max = 0, max\n        self.a, self.b = 0, 1\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.n < self.max:\n            self.n += 1\n            self.a, self.b = self.b, self.a + self.b\n            return self.a\n        else:\n            raise StopIteration\n\nif __name__ == '__main__':\n    fib = Fib(10)\n    print(isinstance(fib, Iterable)) # True\n    print(isinstance(fib, Iterator)) # True\n    print([e for e in fib]) # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n```\n\nFib既是一个可迭代对象（因为它实现了\\_\\_iter\\_\\_方法），又是一个迭代器（因为实现了\\_\\_next\\_\\_方法）。实例变量a和b用于维护迭代器内部的状态。每次调用next()方法的时候做两件事：\n为下一次调用next()方法修改状态，为当前这次调用生成返回结果。    \n\n**迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。**\n\n\n## 3. 生成器(generator)\n生成器是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写\\_\\_iter\\_\\_()和\\_\\_next\\_\\_()方法了，只需要一个yiled关键字。 \n\n用生成器来实现斐波那契数列的例子是：\n```python\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        n = n + 1\n        a, b = b, b + a\n        yield a\n\nf = fib(10)\nprint(f) # <generator object fib at 0x10d8cf888>\nprint([e for e in f])   # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n```\nfib函数中的yield关键字，将该函数变成了一个生成器，当执行f=fib(10)返回的是一个生成器对象，此时函数中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码，在每次调用next()方法时，遇到yield语句返回值并中断，再次执行时从上次返回的yield语句处继续执行。\n生成器是python非常强大的特性，相比其他容器对象它更加节省内存，同时使用更少的代码，使你的代码更加的优雅，凡事以下结构都可以通过生成器重构：\n```python\ndef fun():\n    result = []\n    for ... in ...:\n        result.append(x)\n    return result\n\ndef fun_gen():\n    for ... in ...:\n        yield x\n```\n\n## 4. 总结\n1. 可迭代对象实现了\\_\\_iter\\_\\_方法，该方法返回一个迭代器对象。\n2. 迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了\\_\\_next\\_\\_和\\_\\_iter\\_\\_方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。\n3. 生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。\n","slug":"python-生成器迭代器","published":1,"updated":"2020-06-18T15:16:44.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbllvcmp0004v7gpaxse3m54","content":"<p>&emsp;&emsp;在学习python数据结构的过程中，可迭代对象，迭代器，生成器这些概念参杂在一起，难免让初学者一头雾水，今天就来捋捋这些概览。</p>\n<h2 id=\"1-可迭代对象-iterable\"><a href=\"#1-可迭代对象-iterable\" class=\"headerlink\" title=\"1. 可迭代对象(iterable)\"></a>1. 可迭代对象(iterable)</h2><p>什么是可迭代对象，通俗的讲就是可以直接通过for循环遍历的对象就可称为可迭代对象Iterable，可以使用isinstance()判断一个对象是否是Iterable对象：<br><a id=\"more\"></a></p>\n<blockquote>\n<p>&gt;&gt;&gt;from collections import Iterable<br>&gt;&gt;&gt;isinstance([], Iterable)<br>True<br>&gt;&gt;&gt;isinstance({}, Iterable)<br>True<br>&gt;&gt;&gt;isinstance(‘123’, Iterable)<br>True<br>&gt;&gt;&gt;isinstance(123, Iterable)<br>False   </p>\n</blockquote>\n<p>可迭代对象并不指某种具体的数据类型，list, dict, set, str都是迭代对象，再比如打开状态的files，sockets也是可迭代对象，可迭代对象是指代对象的一种属性，代表该对象是可迭代的。可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。</p>\n<h2 id=\"2-迭代器-iterator\"><a href=\"#2-迭代器-iterator\" class=\"headerlink\" title=\"2. 迭代器(iterator)\"></a>2. 迭代器(iterator)</h2><p>任何实现了__iter__和__next__方法的对象都是迭代器（python2是实现__iter__和next方法），__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常。可以使用isinstance()判断一个对象是否是Iterator对象：</p>\n<blockquote>\n<p>&gt;&gt;&gt;from collections import Iterator<br>&gt;&gt;&gt;isinstance([], Iterator)<br>False<br>&gt;&gt;&gt;isinstance({}, Iterator)<br>False<br>&gt;&gt;&gt;isinstance(‘123’, Iterator)<br>False<br>&gt;&gt;&gt;isinstance((x for x in range(10)), Iterator)<br>True  </p>\n</blockquote>\n<p>其中(x for x in range(10))是生成器表达式，它返回的是一个生成器对象，不同于列表生成式[x for x in range(10)]返回一个list对象。生成器对象都是迭代器对象，但list, dict, str虽然是可迭代对象，但不是迭代器对象，可以使用iter()将list, dict, str等可迭代对象变成迭代器对象。</p>\n<blockquote>\n<p>&gt;&gt;&gt;isinstance(iter([]), Iterator)<br>True<br>&gt;&gt;&gt;isinstance(iter(‘123’), Iterator)<br>True   </p>\n</blockquote>\n<p>python的迭代器对象表示一个数据流，可以将这个数据流看作一个有序序列，但我们并不知道序列的长度，只能不断通过调用next()函数实现按需计算下一个数据，因此迭代器的计算是惰性的，只有在需要返回下一个数据时它才计算，迭代器的这种特性可以大大减少内存的开销，迭代器对象甚至可以表示一个无限大的数据流，而让list, dict或者str存储一个无限大的数据流是不可能的。</p>\n<p>下面我们通过迭代器来实现斐波那契数列：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</span><br><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, max)</span>:</span></span><br><span class=\"line\">        self.n, self.max = <span class=\"number\">0</span>, max</span><br><span class=\"line\">        self.a, self.b = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__next__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.n &lt; self.max:</span><br><span class=\"line\">            self.n += <span class=\"number\">1</span></span><br><span class=\"line\">            self.a, self.b = self.b, self.a + self.b</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.a</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StopIteration</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    fib = Fib(<span class=\"number\">10</span>)</span><br><span class=\"line\">    print(isinstance(fib, Iterable)) <span class=\"comment\"># True</span></span><br><span class=\"line\">    print(isinstance(fib, Iterator)) <span class=\"comment\"># True</span></span><br><span class=\"line\">    print([e <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> fib]) <span class=\"comment\"># [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br></pre></td></tr></table></figure></p>\n<p>Fib既是一个可迭代对象（因为它实现了__iter__方法），又是一个迭代器（因为实现了__next__方法）。实例变量a和b用于维护迭代器内部的状态。每次调用next()方法的时候做两件事：<br>为下一次调用next()方法修改状态，为当前这次调用生成返回结果。    </p>\n<p><strong>迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。</strong></p>\n<h2 id=\"3-生成器-generator\"><a href=\"#3-生成器-generator\" class=\"headerlink\" title=\"3. 生成器(generator)\"></a>3. 生成器(generator)</h2><p>生成器是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写__iter__()和__next__()方法了，只需要一个yiled关键字。 </p>\n<p>用生成器来实现斐波那契数列的例子是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(max)</span>:</span></span><br><span class=\"line\">    n, a, b = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; max:</span><br><span class=\"line\">        n = n + <span class=\"number\">1</span></span><br><span class=\"line\">        a, b = b, b + a</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> a</span><br><span class=\"line\"></span><br><span class=\"line\">f = fib(<span class=\"number\">10</span>)</span><br><span class=\"line\">print(f) <span class=\"comment\"># &lt;generator object fib at 0x10d8cf888&gt;</span></span><br><span class=\"line\">print([e <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> f])   <span class=\"comment\"># [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br></pre></td></tr></table></figure></p>\n<p>fib函数中的yield关键字，将该函数变成了一个生成器，当执行f=fib(10)返回的是一个生成器对象，此时函数中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码，在每次调用next()方法时，遇到yield语句返回值并中断，再次执行时从上次返回的yield语句处继续执行。<br>生成器是python非常强大的特性，相比其他容器对象它更加节省内存，同时使用更少的代码，使你的代码更加的优雅，凡事以下结构都可以通过生成器重构：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ... <span class=\"keyword\">in</span> ...:</span><br><span class=\"line\">        result.append(x)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun_gen</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ... <span class=\"keyword\">in</span> ...:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h2><ol>\n<li>可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。</li>\n<li>迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__next__和__iter__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。</li>\n<li>生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;在学习python数据结构的过程中，可迭代对象，迭代器，生成器这些概念参杂在一起，难免让初学者一头雾水，今天就来捋捋这些概览。</p>\n<h2 id=\"1-可迭代对象-iterable\"><a href=\"#1-可迭代对象-iterable\" class=\"headerlink\" title=\"1. 可迭代对象(iterable)\"></a>1. 可迭代对象(iterable)</h2><p>什么是可迭代对象，通俗的讲就是可以直接通过for循环遍历的对象就可称为可迭代对象Iterable，可以使用isinstance()判断一个对象是否是Iterable对象：<br>","more":"</p>\n<blockquote>\n<p>&gt;&gt;&gt;from collections import Iterable<br>&gt;&gt;&gt;isinstance([], Iterable)<br>True<br>&gt;&gt;&gt;isinstance({}, Iterable)<br>True<br>&gt;&gt;&gt;isinstance(‘123’, Iterable)<br>True<br>&gt;&gt;&gt;isinstance(123, Iterable)<br>False   </p>\n</blockquote>\n<p>可迭代对象并不指某种具体的数据类型，list, dict, set, str都是迭代对象，再比如打开状态的files，sockets也是可迭代对象，可迭代对象是指代对象的一种属性，代表该对象是可迭代的。可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。</p>\n<h2 id=\"2-迭代器-iterator\"><a href=\"#2-迭代器-iterator\" class=\"headerlink\" title=\"2. 迭代器(iterator)\"></a>2. 迭代器(iterator)</h2><p>任何实现了__iter__和__next__方法的对象都是迭代器（python2是实现__iter__和next方法），__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常。可以使用isinstance()判断一个对象是否是Iterator对象：</p>\n<blockquote>\n<p>&gt;&gt;&gt;from collections import Iterator<br>&gt;&gt;&gt;isinstance([], Iterator)<br>False<br>&gt;&gt;&gt;isinstance({}, Iterator)<br>False<br>&gt;&gt;&gt;isinstance(‘123’, Iterator)<br>False<br>&gt;&gt;&gt;isinstance((x for x in range(10)), Iterator)<br>True  </p>\n</blockquote>\n<p>其中(x for x in range(10))是生成器表达式，它返回的是一个生成器对象，不同于列表生成式[x for x in range(10)]返回一个list对象。生成器对象都是迭代器对象，但list, dict, str虽然是可迭代对象，但不是迭代器对象，可以使用iter()将list, dict, str等可迭代对象变成迭代器对象。</p>\n<blockquote>\n<p>&gt;&gt;&gt;isinstance(iter([]), Iterator)<br>True<br>&gt;&gt;&gt;isinstance(iter(‘123’), Iterator)<br>True   </p>\n</blockquote>\n<p>python的迭代器对象表示一个数据流，可以将这个数据流看作一个有序序列，但我们并不知道序列的长度，只能不断通过调用next()函数实现按需计算下一个数据，因此迭代器的计算是惰性的，只有在需要返回下一个数据时它才计算，迭代器的这种特性可以大大减少内存的开销，迭代器对象甚至可以表示一个无限大的数据流，而让list, dict或者str存储一个无限大的数据流是不可能的。</p>\n<p>下面我们通过迭代器来实现斐波那契数列：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</span><br><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, max)</span>:</span></span><br><span class=\"line\">        self.n, self.max = <span class=\"number\">0</span>, max</span><br><span class=\"line\">        self.a, self.b = <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__next__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.n &lt; self.max:</span><br><span class=\"line\">            self.n += <span class=\"number\">1</span></span><br><span class=\"line\">            self.a, self.b = self.b, self.a + self.b</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.a</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StopIteration</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    fib = Fib(<span class=\"number\">10</span>)</span><br><span class=\"line\">    print(isinstance(fib, Iterable)) <span class=\"comment\"># True</span></span><br><span class=\"line\">    print(isinstance(fib, Iterator)) <span class=\"comment\"># True</span></span><br><span class=\"line\">    print([e <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> fib]) <span class=\"comment\"># [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br></pre></td></tr></table></figure></p>\n<p>Fib既是一个可迭代对象（因为它实现了__iter__方法），又是一个迭代器（因为实现了__next__方法）。实例变量a和b用于维护迭代器内部的状态。每次调用next()方法的时候做两件事：<br>为下一次调用next()方法修改状态，为当前这次调用生成返回结果。    </p>\n<p><strong>迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。</strong></p>\n<h2 id=\"3-生成器-generator\"><a href=\"#3-生成器-generator\" class=\"headerlink\" title=\"3. 生成器(generator)\"></a>3. 生成器(generator)</h2><p>生成器是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写__iter__()和__next__()方法了，只需要一个yiled关键字。 </p>\n<p>用生成器来实现斐波那契数列的例子是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(max)</span>:</span></span><br><span class=\"line\">    n, a, b = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; max:</span><br><span class=\"line\">        n = n + <span class=\"number\">1</span></span><br><span class=\"line\">        a, b = b, b + a</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> a</span><br><span class=\"line\"></span><br><span class=\"line\">f = fib(<span class=\"number\">10</span>)</span><br><span class=\"line\">print(f) <span class=\"comment\"># &lt;generator object fib at 0x10d8cf888&gt;</span></span><br><span class=\"line\">print([e <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> f])   <span class=\"comment\"># [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br></pre></td></tr></table></figure></p>\n<p>fib函数中的yield关键字，将该函数变成了一个生成器，当执行f=fib(10)返回的是一个生成器对象，此时函数中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码，在每次调用next()方法时，遇到yield语句返回值并中断，再次执行时从上次返回的yield语句处继续执行。<br>生成器是python非常强大的特性，相比其他容器对象它更加节省内存，同时使用更少的代码，使你的代码更加的优雅，凡事以下结构都可以通过生成器重构：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ... <span class=\"keyword\">in</span> ...:</span><br><span class=\"line\">        result.append(x)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun_gen</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ... <span class=\"keyword\">in</span> ...:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h2><ol>\n<li>可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。</li>\n<li>迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__next__和__iter__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。</li>\n<li>生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。</li>\n</ol>"},{"title":"Python装饰器","date":"2020-06-17T02:37:55.000Z","_content":"\n&emsp;&emsp;装饰器(Decorator)可以在不修改函数的情况下，增强函数的功能，有助于公用逻辑的复用，增强程序的可读性，在python中有着举足轻重的地位。\n\n## 1. 一切皆对象，函数也是对象\n要想知道装饰器的原理，需要先知道python中函数也是对象，函数可以赋值给变量，函数可以作为返回值，函数可以作为参数传递。\n<!-- more -->\n```python\n# 函数赋值给变量，通过变量调用\ndef func1():\n    print(\"Hello World\")\nf1 = func1\nf1()    # \"Hello World\"\n\n# 函数作为返回值， 函数赋值给变量，通过变量调用\ndef func2():\n    def inner():\n        print(\"Hello World\")\n    return inner\nf2 = func2()\nf2()  # \"Hello World\"\n\n# 函数作为参数，函数赋值给变量，通过变量调用\ndef func3():\n    print(\"Hello World\")\n\ndef wrapper(func):\n    return func()\n\nwrapper(func3)  # \"Hello World\"\n\n```\n\n## 2. 简单装饰器\n有了上面的基础，现在我们给出一个简单的装饰器的例子\n```python\ndef log1(func):\n    def wrapper(*args, **kw):\n        print(\"func: %s, input: args: %s, kw: %s\"%(func.__name__, args, kw))\n        result = func(*args, **kw)\n        print(\"output: %s\"%(result))\n        return result\n    return wrapper\n\ndef func1(a, b):\n    return a + b\n\nf1 = log1(func1)\nf1(1, 2)\n# func: func1, input: args: (1, 2), kw: {}\n# output: 3\n```\n**装饰器log1接收一个函数func作为参数，同时返回内部函数wrapper。f1指向wrapper，调用f1(1, 2)时，wrapper接收f1的参数并在内部调用了func1，这样在不修改func1的基础上既实现func1功能，同时又为func1增加了格外的功能（打印了func1的输入输出记录）。**\n\n其中f1 = log1(func1) 可借助@语法糖在函数定义处简写为\n```python\n@log1\ndef func1(a, b):\n    return a + b\n```\n\n## 3. 带参数的装饰器\n当装饰器需要传入参数时，需要在简单装饰器外层再包装一层，用来传递装饰器的参数\n```python\ndef log2(name=None):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            logname = name if name else func.__name__\n            print(\"name: %s, input: args: %s, kw: %s\"%(logname, args, kw))\n            result = func(*args, **kw)\n            print(\"output: %s\"%(result))\n            return result\n        return wrapper\n    return decorator\n\n@log2(\"sum\")\ndef func2(a, b):\n    return a + b\n\nfunc2(1, 2)\n# name: sum, input: args: (1, 2), kw: {}\n# output: 3\n\n# 这种3层嵌套相当于func2 = log2(\"sum\")(func2)\n```\n带参数的装饰器同样支持默认参数，当使用默认参数时，应写为@log2()，而不是@log2\n\n## 4. 保留函数元信息\n>&gt;&gt;&gt; print(func1.\\_\\_name\\_\\_)\n>wrapper   \n>&gt;&gt;&gt; print(func2.\\_\\_name\\_\\_)\n>wrapper   \n\n打印被装饰函数的\\_\\_name\\_\\_属性，发现不再是原来的函数名，函数的元信息已丢失，这将导致某些依靠函数元信息的代码执行出错。为了解决这个问题，需要使用python内置装饰器functools.wraps来注解底层包装函数，完整的代码如下：\n```python\nimport functools\n\ndef log1(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print(\"func: %s, input: args: %s, kw: %s\"%(func.__name__, args, kw))\n        result = func(*args, **kw)\n        print(\"output: %s\"%(result))\n        return result\n    return wrapper\n\ndef log2(name=None):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            logname = name if name else func.__name__\n            print(\"name: %s, input: args: %s, kw: %s\"%(logname, args, kw))\n            result = func(*args, **kw)\n            print(\"output: %s\"%(result))\n            return result\n        return wrapper\n    return decorator\n\n@log1\ndef func1(a, b):\n    return a + b\n\n@log2(\"sum\")\ndef func2(a, b):\n    return a + b\n\nfunc1(1, 2)\n# func: func1, input: args: (1, 2), kw: {}\n# output: 3\n\nfunc2(1, 2)\n# name: sum, input: args: (1, 2), kw: {}\n# output: 3\n\nprint(func1.__name__)   # func1\nprint(func2.__name__)   # func2\n```\n\n## 5. 类装饰器\n类的\\_\\_call\\_\\_方法可以让实例像函数一样被调用，这样我们可以将装饰器的逻辑放在\\_\\_call\\_\\_方法内部实现，这样做的好处是可以使用类的特性，例如继承等。\n```python\nimport functools\n\nclass BaseDecorator(object):\n    def __call__(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            self.doSomeThings()\n            return func(*args, **kwargs)\n        return wrapper\n\n    def doSomeThings(self):\n        pass\n\nclass ChildDecorator(BaseDecorator):\n    def doSomeThings(self):\n        print(\"Hello World\")\n\n@ChildDecorator()\ndef func1():\n    pass\n\nfunc1()\n# Hello World\n```\n\n## 6. 多个装饰器调用顺序\n```python\n@a\n@b\n@c\ndef func():\n    pass\n```\n当一个函数被多个装饰器修饰时，执行顺序是从下往上执行，上述例子等价于 func = a(b(c(func)))。\n\n\n","source":"_posts/python-装饰器.md","raw":"---\ntitle: Python装饰器\ndate: 2020-06-17 10:37:55\ntags: [python]\n---\n\n&emsp;&emsp;装饰器(Decorator)可以在不修改函数的情况下，增强函数的功能，有助于公用逻辑的复用，增强程序的可读性，在python中有着举足轻重的地位。\n\n## 1. 一切皆对象，函数也是对象\n要想知道装饰器的原理，需要先知道python中函数也是对象，函数可以赋值给变量，函数可以作为返回值，函数可以作为参数传递。\n<!-- more -->\n```python\n# 函数赋值给变量，通过变量调用\ndef func1():\n    print(\"Hello World\")\nf1 = func1\nf1()    # \"Hello World\"\n\n# 函数作为返回值， 函数赋值给变量，通过变量调用\ndef func2():\n    def inner():\n        print(\"Hello World\")\n    return inner\nf2 = func2()\nf2()  # \"Hello World\"\n\n# 函数作为参数，函数赋值给变量，通过变量调用\ndef func3():\n    print(\"Hello World\")\n\ndef wrapper(func):\n    return func()\n\nwrapper(func3)  # \"Hello World\"\n\n```\n\n## 2. 简单装饰器\n有了上面的基础，现在我们给出一个简单的装饰器的例子\n```python\ndef log1(func):\n    def wrapper(*args, **kw):\n        print(\"func: %s, input: args: %s, kw: %s\"%(func.__name__, args, kw))\n        result = func(*args, **kw)\n        print(\"output: %s\"%(result))\n        return result\n    return wrapper\n\ndef func1(a, b):\n    return a + b\n\nf1 = log1(func1)\nf1(1, 2)\n# func: func1, input: args: (1, 2), kw: {}\n# output: 3\n```\n**装饰器log1接收一个函数func作为参数，同时返回内部函数wrapper。f1指向wrapper，调用f1(1, 2)时，wrapper接收f1的参数并在内部调用了func1，这样在不修改func1的基础上既实现func1功能，同时又为func1增加了格外的功能（打印了func1的输入输出记录）。**\n\n其中f1 = log1(func1) 可借助@语法糖在函数定义处简写为\n```python\n@log1\ndef func1(a, b):\n    return a + b\n```\n\n## 3. 带参数的装饰器\n当装饰器需要传入参数时，需要在简单装饰器外层再包装一层，用来传递装饰器的参数\n```python\ndef log2(name=None):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            logname = name if name else func.__name__\n            print(\"name: %s, input: args: %s, kw: %s\"%(logname, args, kw))\n            result = func(*args, **kw)\n            print(\"output: %s\"%(result))\n            return result\n        return wrapper\n    return decorator\n\n@log2(\"sum\")\ndef func2(a, b):\n    return a + b\n\nfunc2(1, 2)\n# name: sum, input: args: (1, 2), kw: {}\n# output: 3\n\n# 这种3层嵌套相当于func2 = log2(\"sum\")(func2)\n```\n带参数的装饰器同样支持默认参数，当使用默认参数时，应写为@log2()，而不是@log2\n\n## 4. 保留函数元信息\n>&gt;&gt;&gt; print(func1.\\_\\_name\\_\\_)\n>wrapper   \n>&gt;&gt;&gt; print(func2.\\_\\_name\\_\\_)\n>wrapper   \n\n打印被装饰函数的\\_\\_name\\_\\_属性，发现不再是原来的函数名，函数的元信息已丢失，这将导致某些依靠函数元信息的代码执行出错。为了解决这个问题，需要使用python内置装饰器functools.wraps来注解底层包装函数，完整的代码如下：\n```python\nimport functools\n\ndef log1(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print(\"func: %s, input: args: %s, kw: %s\"%(func.__name__, args, kw))\n        result = func(*args, **kw)\n        print(\"output: %s\"%(result))\n        return result\n    return wrapper\n\ndef log2(name=None):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            logname = name if name else func.__name__\n            print(\"name: %s, input: args: %s, kw: %s\"%(logname, args, kw))\n            result = func(*args, **kw)\n            print(\"output: %s\"%(result))\n            return result\n        return wrapper\n    return decorator\n\n@log1\ndef func1(a, b):\n    return a + b\n\n@log2(\"sum\")\ndef func2(a, b):\n    return a + b\n\nfunc1(1, 2)\n# func: func1, input: args: (1, 2), kw: {}\n# output: 3\n\nfunc2(1, 2)\n# name: sum, input: args: (1, 2), kw: {}\n# output: 3\n\nprint(func1.__name__)   # func1\nprint(func2.__name__)   # func2\n```\n\n## 5. 类装饰器\n类的\\_\\_call\\_\\_方法可以让实例像函数一样被调用，这样我们可以将装饰器的逻辑放在\\_\\_call\\_\\_方法内部实现，这样做的好处是可以使用类的特性，例如继承等。\n```python\nimport functools\n\nclass BaseDecorator(object):\n    def __call__(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            self.doSomeThings()\n            return func(*args, **kwargs)\n        return wrapper\n\n    def doSomeThings(self):\n        pass\n\nclass ChildDecorator(BaseDecorator):\n    def doSomeThings(self):\n        print(\"Hello World\")\n\n@ChildDecorator()\ndef func1():\n    pass\n\nfunc1()\n# Hello World\n```\n\n## 6. 多个装饰器调用顺序\n```python\n@a\n@b\n@c\ndef func():\n    pass\n```\n当一个函数被多个装饰器修饰时，执行顺序是从下往上执行，上述例子等价于 func = a(b(c(func)))。\n\n\n","slug":"python-装饰器","published":1,"updated":"2020-06-18T14:51:34.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbllvcn3000av7gpcv5xpokc","content":"<p>&emsp;&emsp;装饰器(Decorator)可以在不修改函数的情况下，增强函数的功能，有助于公用逻辑的复用，增强程序的可读性，在python中有着举足轻重的地位。</p>\n<h2 id=\"1-一切皆对象，函数也是对象\"><a href=\"#1-一切皆对象，函数也是对象\" class=\"headerlink\" title=\"1. 一切皆对象，函数也是对象\"></a>1. 一切皆对象，函数也是对象</h2><p>要想知道装饰器的原理，需要先知道python中函数也是对象，函数可以赋值给变量，函数可以作为返回值，函数可以作为参数传递。<br><a id=\"more\"></a><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 函数赋值给变量，通过变量调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"Hello World\"</span>)</span><br><span class=\"line\">f1 = func1</span><br><span class=\"line\">f1()    <span class=\"comment\"># \"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 函数作为返回值， 函数赋值给变量，通过变量调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Hello World\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\">f2 = func2()</span><br><span class=\"line\">f2()  <span class=\"comment\"># \"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 函数作为参数，函数赋值给变量，通过变量调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func3</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"Hello World\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func()</span><br><span class=\"line\"></span><br><span class=\"line\">wrapper(func3)  <span class=\"comment\"># \"Hello World\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-简单装饰器\"><a href=\"#2-简单装饰器\" class=\"headerlink\" title=\"2. 简单装饰器\"></a>2. 简单装饰器</h2><p>有了上面的基础，现在我们给出一个简单的装饰器的例子<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log1</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"func: %s, input: args: %s, kw: %s\"</span>%(func.__name__, args, kw))</span><br><span class=\"line\">        result = func(*args, **kw)</span><br><span class=\"line\">        print(<span class=\"string\">\"output: %s\"</span>%(result))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\">f1 = log1(func1)</span><br><span class=\"line\">f1(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># func: func1, input: args: (1, 2), kw: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># output: 3</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>装饰器log1接收一个函数func作为参数，同时返回内部函数wrapper。f1指向wrapper，调用f1(1, 2)时，wrapper接收f1的参数并在内部调用了func1，这样在不修改func1的基础上既实现func1功能，同时又为func1增加了格外的功能（打印了func1的输入输出记录）。</strong></p>\n<p>其中f1 = log1(func1) 可借助@语法糖在函数定义处简写为<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@log1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-带参数的装饰器\"><a href=\"#3-带参数的装饰器\" class=\"headerlink\" title=\"3. 带参数的装饰器\"></a>3. 带参数的装饰器</h2><p>当装饰器需要传入参数时，需要在简单装饰器外层再包装一层，用来传递装饰器的参数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log2</span><span class=\"params\">(name=None)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">            logname = name <span class=\"keyword\">if</span> name <span class=\"keyword\">else</span> func.__name__</span><br><span class=\"line\">            print(<span class=\"string\">\"name: %s, input: args: %s, kw: %s\"</span>%(logname, args, kw))</span><br><span class=\"line\">            result = func(*args, **kw)</span><br><span class=\"line\">            print(<span class=\"string\">\"output: %s\"</span>%(result))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log2(\"sum\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\">func2(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># name: sum, input: args: (1, 2), kw: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># output: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这种3层嵌套相当于func2 = log2(\"sum\")(func2)</span></span><br></pre></td></tr></table></figure></p>\n<p>带参数的装饰器同样支持默认参数，当使用默认参数时，应写为@log2()，而不是@log2</p>\n<h2 id=\"4-保留函数元信息\"><a href=\"#4-保留函数元信息\" class=\"headerlink\" title=\"4. 保留函数元信息\"></a>4. 保留函数元信息</h2><blockquote>\n<p>&gt;&gt;&gt; print(func1.__name__)<br>wrapper<br>&gt;&gt;&gt; print(func2.__name__)<br>wrapper   </p>\n</blockquote>\n<p>打印被装饰函数的__name__属性，发现不再是原来的函数名，函数的元信息已丢失，这将导致某些依靠函数元信息的代码执行出错。为了解决这个问题，需要使用python内置装饰器functools.wraps来注解底层包装函数，完整的代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log1</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"func: %s, input: args: %s, kw: %s\"</span>%(func.__name__, args, kw))</span><br><span class=\"line\">        result = func(*args, **kw)</span><br><span class=\"line\">        print(<span class=\"string\">\"output: %s\"</span>%(result))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log2</span><span class=\"params\">(name=None)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">        @functools.wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">            logname = name <span class=\"keyword\">if</span> name <span class=\"keyword\">else</span> func.__name__</span><br><span class=\"line\">            print(<span class=\"string\">\"name: %s, input: args: %s, kw: %s\"</span>%(logname, args, kw))</span><br><span class=\"line\">            result = func(*args, **kw)</span><br><span class=\"line\">            print(<span class=\"string\">\"output: %s\"</span>%(result))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log2(\"sum\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\">func1(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># func: func1, input: args: (1, 2), kw: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># output: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">func2(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># name: sum, input: args: (1, 2), kw: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># output: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(func1.__name__)   <span class=\"comment\"># func1</span></span><br><span class=\"line\">print(func2.__name__)   <span class=\"comment\"># func2</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-类装饰器\"><a href=\"#5-类装饰器\" class=\"headerlink\" title=\"5. 类装饰器\"></a>5. 类装饰器</h2><p>类的__call__方法可以让实例像函数一样被调用，这样我们可以将装饰器的逻辑放在__call__方法内部实现，这样做的好处是可以使用类的特性，例如继承等。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseDecorator</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">        @functools.wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">            self.doSomeThings()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">doSomeThings</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildDecorator</span><span class=\"params\">(BaseDecorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">doSomeThings</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Hello World\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ChildDecorator()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">func1()</span><br><span class=\"line\"><span class=\"comment\"># Hello World</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-多个装饰器调用顺序\"><a href=\"#6-多个装饰器调用顺序\" class=\"headerlink\" title=\"6. 多个装饰器调用顺序\"></a>6. 多个装饰器调用顺序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@a</span></span><br><span class=\"line\"><span class=\"meta\">@b</span></span><br><span class=\"line\"><span class=\"meta\">@c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>当一个函数被多个装饰器修饰时，执行顺序是从下往上执行，上述例子等价于 func = a(b(c(func)))。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;装饰器(Decorator)可以在不修改函数的情况下，增强函数的功能，有助于公用逻辑的复用，增强程序的可读性，在python中有着举足轻重的地位。</p>\n<h2 id=\"1-一切皆对象，函数也是对象\"><a href=\"#1-一切皆对象，函数也是对象\" class=\"headerlink\" title=\"1. 一切皆对象，函数也是对象\"></a>1. 一切皆对象，函数也是对象</h2><p>要想知道装饰器的原理，需要先知道python中函数也是对象，函数可以赋值给变量，函数可以作为返回值，函数可以作为参数传递。<br>","more":"<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 函数赋值给变量，通过变量调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"Hello World\"</span>)</span><br><span class=\"line\">f1 = func1</span><br><span class=\"line\">f1()    <span class=\"comment\"># \"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 函数作为返回值， 函数赋值给变量，通过变量调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Hello World\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\">f2 = func2()</span><br><span class=\"line\">f2()  <span class=\"comment\"># \"Hello World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 函数作为参数，函数赋值给变量，通过变量调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func3</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"Hello World\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func()</span><br><span class=\"line\"></span><br><span class=\"line\">wrapper(func3)  <span class=\"comment\"># \"Hello World\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-简单装饰器\"><a href=\"#2-简单装饰器\" class=\"headerlink\" title=\"2. 简单装饰器\"></a>2. 简单装饰器</h2><p>有了上面的基础，现在我们给出一个简单的装饰器的例子<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log1</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"func: %s, input: args: %s, kw: %s\"</span>%(func.__name__, args, kw))</span><br><span class=\"line\">        result = func(*args, **kw)</span><br><span class=\"line\">        print(<span class=\"string\">\"output: %s\"</span>%(result))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\">f1 = log1(func1)</span><br><span class=\"line\">f1(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># func: func1, input: args: (1, 2), kw: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># output: 3</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>装饰器log1接收一个函数func作为参数，同时返回内部函数wrapper。f1指向wrapper，调用f1(1, 2)时，wrapper接收f1的参数并在内部调用了func1，这样在不修改func1的基础上既实现func1功能，同时又为func1增加了格外的功能（打印了func1的输入输出记录）。</strong></p>\n<p>其中f1 = log1(func1) 可借助@语法糖在函数定义处简写为<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@log1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-带参数的装饰器\"><a href=\"#3-带参数的装饰器\" class=\"headerlink\" title=\"3. 带参数的装饰器\"></a>3. 带参数的装饰器</h2><p>当装饰器需要传入参数时，需要在简单装饰器外层再包装一层，用来传递装饰器的参数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log2</span><span class=\"params\">(name=None)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">            logname = name <span class=\"keyword\">if</span> name <span class=\"keyword\">else</span> func.__name__</span><br><span class=\"line\">            print(<span class=\"string\">\"name: %s, input: args: %s, kw: %s\"</span>%(logname, args, kw))</span><br><span class=\"line\">            result = func(*args, **kw)</span><br><span class=\"line\">            print(<span class=\"string\">\"output: %s\"</span>%(result))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log2(\"sum\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\">func2(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># name: sum, input: args: (1, 2), kw: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># output: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这种3层嵌套相当于func2 = log2(\"sum\")(func2)</span></span><br></pre></td></tr></table></figure></p>\n<p>带参数的装饰器同样支持默认参数，当使用默认参数时，应写为@log2()，而不是@log2</p>\n<h2 id=\"4-保留函数元信息\"><a href=\"#4-保留函数元信息\" class=\"headerlink\" title=\"4. 保留函数元信息\"></a>4. 保留函数元信息</h2><blockquote>\n<p>&gt;&gt;&gt; print(func1.__name__)<br>wrapper<br>&gt;&gt;&gt; print(func2.__name__)<br>wrapper   </p>\n</blockquote>\n<p>打印被装饰函数的__name__属性，发现不再是原来的函数名，函数的元信息已丢失，这将导致某些依靠函数元信息的代码执行出错。为了解决这个问题，需要使用python内置装饰器functools.wraps来注解底层包装函数，完整的代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log1</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"func: %s, input: args: %s, kw: %s\"</span>%(func.__name__, args, kw))</span><br><span class=\"line\">        result = func(*args, **kw)</span><br><span class=\"line\">        print(<span class=\"string\">\"output: %s\"</span>%(result))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log2</span><span class=\"params\">(name=None)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">        @functools.wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">            logname = name <span class=\"keyword\">if</span> name <span class=\"keyword\">else</span> func.__name__</span><br><span class=\"line\">            print(<span class=\"string\">\"name: %s, input: args: %s, kw: %s\"</span>%(logname, args, kw))</span><br><span class=\"line\">            result = func(*args, **kw)</span><br><span class=\"line\">            print(<span class=\"string\">\"output: %s\"</span>%(result))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log2(\"sum\")</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\"></span><br><span class=\"line\">func1(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># func: func1, input: args: (1, 2), kw: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># output: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">func2(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># name: sum, input: args: (1, 2), kw: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># output: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(func1.__name__)   <span class=\"comment\"># func1</span></span><br><span class=\"line\">print(func2.__name__)   <span class=\"comment\"># func2</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-类装饰器\"><a href=\"#5-类装饰器\" class=\"headerlink\" title=\"5. 类装饰器\"></a>5. 类装饰器</h2><p>类的__call__方法可以让实例像函数一样被调用，这样我们可以将装饰器的逻辑放在__call__方法内部实现，这样做的好处是可以使用类的特性，例如继承等。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseDecorator</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">        @functools.wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">            self.doSomeThings()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">doSomeThings</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildDecorator</span><span class=\"params\">(BaseDecorator)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">doSomeThings</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Hello World\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ChildDecorator()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">func1()</span><br><span class=\"line\"><span class=\"comment\"># Hello World</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-多个装饰器调用顺序\"><a href=\"#6-多个装饰器调用顺序\" class=\"headerlink\" title=\"6. 多个装饰器调用顺序\"></a>6. 多个装饰器调用顺序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@a</span></span><br><span class=\"line\"><span class=\"meta\">@b</span></span><br><span class=\"line\"><span class=\"meta\">@c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>当一个函数被多个装饰器修饰时，执行顺序是从下往上执行，上述例子等价于 func = a(b(c(func)))。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckbllvcmh0001v7gpgp30bc7s","tag_id":"ckbllvcmn0003v7gp70ltpa6n","_id":"ckbllvcmr0006v7gpyumj3yv8"},{"post_id":"ckbllvcmm0002v7gp6psnqgaf","tag_id":"ckbllvcmq0005v7gp7uxpt0as","_id":"ckbllvcmu0008v7gpszfkjxig"},{"post_id":"ckbllvcmp0004v7gpaxse3m54","tag_id":"ckbllvcmq0005v7gp7uxpt0as","_id":"ckbllvcmu0009v7gpopjso7q1"},{"post_id":"ckbllvcn3000av7gpcv5xpokc","tag_id":"ckbllvcmq0005v7gp7uxpt0as","_id":"ckbllvcn6000cv7gpzecqhekw"}],"Tag":[{"name":"linux","_id":"ckbllvcmn0003v7gp70ltpa6n"},{"name":"python","_id":"ckbllvcmq0005v7gp7uxpt0as"}]}}